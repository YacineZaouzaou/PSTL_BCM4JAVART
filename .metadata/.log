!SESSION 2019-05-12 11:14:38.178 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-12 11:14:39.148
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-12 11:14:39.163
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-12 11:14:39.164
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.egit.core 1 0 2019-05-12 11:14:56.858
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-12 11:14:58.912
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-12 11:14:58.912
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'
!SESSION 2019-05-12 15:52:18.898 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-12 15:52:19.927
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-12 15:52:19.929
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
                     org.apache.xmlrpc [54]
                       Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-12 15:52:19.930
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.egit.core 1 0 2019-05-12 15:52:38.227
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-12 15:52:39.950
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-12 15:52:39.950
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'
!SESSION 2019-05-12 19:25:30.868 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-12 19:25:31.938
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-12 19:25:31.944
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
                     org.apache.xmlrpc [54]
                       Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-12 19:25:31.949
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.egit.core 1 0 2019-05-12 19:25:45.802
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-12 19:25:47.817
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-12 19:25:47.817
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'
!SESSION 2019-05-13 14:18:15.035 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-13 14:18:16.122
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-13 14:18:16.127
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-13 14:18:16.128
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.egit.core 1 0 2019-05-13 14:18:28.310
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-13 14:18:30.297
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-13 14:18:30.297
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'
!SESSION 2019-05-13 15:56:46.901 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-13 15:56:47.828
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-13 15:56:47.831
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
                     org.apache.xmlrpc [54]
                       Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-13 15:56:47.834
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.egit.core 1 0 2019-05-13 15:57:01.739
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-13 15:57:03.354
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-13 15:57:03.354
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'
!SESSION 2019-05-13 16:19:15.341 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-13 16:19:16.354
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-13 16:19:16.358
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
                     org.apache.xmlrpc [54]
                       Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-13 16:19:16.359
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.egit.core 1 0 2019-05-13 16:19:21.632
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-13 16:19:23.316
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-13 16:19:23.316
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'
!SESSION 2019-05-13 17:57:46.707 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data /home/yacine/Documents/Master/S2/PSTL/ -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-13 17:57:47.779
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-13 17:57:47.781
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
                     org.apache.xmlrpc [54]
                       Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-13 17:57:47.790
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.egit.core 1 0 2019-05-13 17:57:50.234
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-13 17:57:52.146
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-13 17:57:52.146
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'
!SESSION 2019-05-24 10:07:00.835 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.3
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-24 10:07:02.036
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-24 10:07:02.039
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-24 10:07:02.039
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.egit.core 1 0 2019-05-24 10:07:31.168
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-24 10:07:33.192
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-24 10:07:33.192
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'
!SESSION 2019-05-24 10:42:16.703 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.3
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data /home/yacine/Documents/Master/S2/PSTL -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-24 10:42:17.734
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-24 10:42:17.741
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
                     org.apache.xmlrpc [54]
                       Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-24 10:42:17.743
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.core.resources 4 567 2019-05-24 10:42:18.937
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2019-05-24 10:42:18.938
!MESSAGE Could not read metadata for 'dynamically-adaptable-components-safe-in-java-master.zip_expanded'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/dynamically-adaptable-components-safe-in-java-master.zip_expanded)[567]: java.lang.Exception: The project description file (.project) for 'dynamically-adaptable-components-safe-in-java-master.zip_expanded' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:906)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:892)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:872)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1564)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2454)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2211)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:489)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:815)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:808)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:765)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1005)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:357)
	at org.eclipse.osgi.container.Module.doStart(Module.java:589)
	at org.eclipse.osgi.container.Module.start(Module.java:457)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:471)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:331)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:395)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:39)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:469)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:422)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:414)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:153)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:156)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2019-05-24 10:42:18.938
!MESSAGE The project description file (.project) for 'dynamically-adaptable-components-safe-in-java-master.zip_expanded' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'dynamically-adaptable-components-safe-in-java-master.zip_expanded' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:906)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:892)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:872)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1564)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2454)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2211)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:489)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:815)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:808)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:765)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1005)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:357)
	at org.eclipse.osgi.container.Module.doStart(Module.java:589)
	at org.eclipse.osgi.container.Module.start(Module.java:457)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:471)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:331)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:395)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:39)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:469)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:422)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:414)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:153)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:156)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)

!ENTRY org.eclipse.egit.core 1 0 2019-05-24 10:42:20.493
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-24 10:42:22.443
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-24 10:42:22.443
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'

!ENTRY org.eclipse.ui 4 0 2019-05-24 12:15:43.410
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4699)
	at org.eclipse.swt.SWT.error(SWT.java:4614)
	at org.eclipse.swt.SWT.error(SWT.java:4585)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:530)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:467)
	at org.eclipse.swt.widgets.Composite.getChildren(Composite.java:736)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceDropAdapter.lambda$0(MarketplaceDropAdapter.java:136)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:5026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4582)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)

!ENTRY org.eclipse.ui 4 0 2019-05-24 12:15:43.411
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4699)
	at org.eclipse.swt.SWT.error(SWT.java:4614)
	at org.eclipse.swt.SWT.error(SWT.java:4585)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:530)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:467)
	at org.eclipse.swt.widgets.Composite.getChildren(Composite.java:736)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceDropAdapter.lambda$0(MarketplaceDropAdapter.java:136)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:5026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4582)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)

!ENTRY org.eclipse.ui 4 0 2019-05-24 12:15:43.412
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4699)
	at org.eclipse.swt.SWT.error(SWT.java:4614)
	at org.eclipse.swt.SWT.error(SWT.java:4585)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:530)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:467)
	at org.eclipse.swt.widgets.Composite.getChildren(Composite.java:736)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceDropAdapter.lambda$0(MarketplaceDropAdapter.java:136)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:5026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4582)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)

!ENTRY org.eclipse.ui 4 0 2019-05-24 12:15:43.412
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4699)
	at org.eclipse.swt.SWT.error(SWT.java:4614)
	at org.eclipse.swt.SWT.error(SWT.java:4585)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:530)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:467)
	at org.eclipse.swt.widgets.Composite.getChildren(Composite.java:736)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceDropAdapter.lambda$0(MarketplaceDropAdapter.java:136)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:5026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4582)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)

!ENTRY org.eclipse.ui 4 0 2019-05-24 12:15:43.413
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4699)
	at org.eclipse.swt.SWT.error(SWT.java:4614)
	at org.eclipse.swt.SWT.error(SWT.java:4585)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:530)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:467)
	at org.eclipse.swt.widgets.Composite.getChildren(Composite.java:736)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceDropAdapter.lambda$0(MarketplaceDropAdapter.java:136)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:5026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4582)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)

!ENTRY org.eclipse.ui 4 0 2019-05-24 12:15:43.413
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4699)
	at org.eclipse.swt.SWT.error(SWT.java:4614)
	at org.eclipse.swt.SWT.error(SWT.java:4585)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:530)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:467)
	at org.eclipse.swt.widgets.Composite.getChildren(Composite.java:736)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceDropAdapter.lambda$0(MarketplaceDropAdapter.java:136)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:5026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4582)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)

!ENTRY org.eclipse.ui 4 0 2019-05-24 12:15:43.414
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4699)
	at org.eclipse.swt.SWT.error(SWT.java:4614)
	at org.eclipse.swt.SWT.error(SWT.java:4585)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:530)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:467)
	at org.eclipse.swt.widgets.Composite.getChildren(Composite.java:736)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceDropAdapter.lambda$0(MarketplaceDropAdapter.java:136)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:5026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4582)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)

!ENTRY org.eclipse.ui 4 0 2019-05-24 12:15:43.414
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4699)
	at org.eclipse.swt.SWT.error(SWT.java:4614)
	at org.eclipse.swt.SWT.error(SWT.java:4585)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:530)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:467)
	at org.eclipse.swt.widgets.Composite.getChildren(Composite.java:736)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceDropAdapter.lambda$0(MarketplaceDropAdapter.java:136)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:5026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4582)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)
!SESSION 2019-05-28 10:19:21.541 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=11.0.3
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data /home/yacine/Documents/Master/S2/PSTL -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.mylyn.bugzilla.core 4 0 2019-05-28 10:19:22.502
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.core [265]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
       org.eclipse.mylyn.commons.xmlrpc [282]
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
              org.apache.xmlrpc [54]
                Unresolved requirement: Import-Package: javax.xml.bind
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.bugzilla.ui 4 0 2019-05-28 10:19:22.505
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.bugzilla.ui [267]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.bugzilla.core; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.bugzilla.core; bundle-version="3.24.2.v20180905-0003"; singleton:="true"
       org.eclipse.mylyn.bugzilla.core [265]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.xmlrpc; bundle-version="[3.8.0,4.0.0)"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.xmlrpc; bundle-version="3.24.2.v20180904-2231"; singleton:="true"
              org.eclipse.mylyn.commons.xmlrpc [282]
                Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
                  -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
                     org.apache.xmlrpc [54]
                       Unresolved requirement: Import-Package: javax.xml.bind
         Unresolved requirement: Require-Bundle: org.apache.xmlrpc
           -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.mylyn.commons.xmlrpc 4 0 2019-05-28 10:19:22.506
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.xmlrpc [282]
  Unresolved requirement: Require-Bundle: org.apache.xmlrpc; bundle-version="[3.0.0,4.0.0)"
    -> Bundle-SymbolicName: org.apache.xmlrpc; bundle-version="3.0.0.v20100427-1100"
       org.apache.xmlrpc [54]
         Unresolved requirement: Import-Package: javax.xml.bind

	at org.eclipse.osgi.container.Module.start(Module.java:452)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1784)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1763)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1726)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1657)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:233)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:343)

!ENTRY org.eclipse.egit.core 1 0 2019-05-28 10:19:24.940
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.mylyn.tasks.core 4 0 2019-05-28 10:19:26.891
!MESSAGE Unexpected error while loading repository template extensions
!SUBENTRY 1 org.eclipse.mylyn.tasks.core 4 0 2019-05-28 10:19:26.892
!MESSAGE Could not load repository template extension contributed by 'org.eclipse.mylyn.bugzilla.ide' with connectorKind 'bugzilla'
<<<<<<< HEAD
!SESSION 2019-05-28 11:24:39.059 -----------------------------------------------
eclipse.buildId=4.11.0.I20190307-0500
java.version=1.8.0_181
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data /home/zineddine/PSTL_BCMRT/PSTL_BCM4JAVART -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2019-05-28 11:24:41.036
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.core.resources 4 567 2019-05-28 11:24:41.093
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2019-05-28 11:24:41.093
!MESSAGE Could not read metadata for 'PSTL'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/PSTL)[567]: java.lang.Exception: The project description file (.project) for 'PSTL' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:906)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:892)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:872)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1564)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2454)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2211)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:489)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:815)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:808)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:765)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1005)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:357)
	at org.eclipse.osgi.container.Module.doStart(Module.java:589)
	at org.eclipse.osgi.container.Module.start(Module.java:457)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:471)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:331)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:395)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:39)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:469)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:422)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:414)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:153)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:156)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2019-05-28 11:24:41.094
!MESSAGE The project description file (.project) for 'PSTL' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'PSTL' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:906)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:892)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:872)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1564)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2454)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2211)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:489)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:815)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:808)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:765)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1005)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:357)
	at org.eclipse.osgi.container.Module.doStart(Module.java:589)
	at org.eclipse.osgi.container.Module.start(Module.java:457)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:471)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:331)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:395)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:39)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:469)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:422)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:414)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:153)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:156)
=======

!ENTRY org.eclipse.ui 4 0 2019-05-28 13:25:47.118
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4699)
	at org.eclipse.swt.SWT.error(SWT.java:4614)
	at org.eclipse.swt.SWT.error(SWT.java:4585)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:530)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:467)
	at org.eclipse.swt.widgets.Composite.getChildren(Composite.java:736)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceDropAdapter.lambda$0(MarketplaceDropAdapter.java:136)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:5026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4582)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1173)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1062)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:155)
>>>>>>> ac8136ce159b1b1fe653767e5b0185718b5eb370
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
<<<<<<< HEAD
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
=======
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
>>>>>>> ac8136ce159b1b1fe653767e5b0185718b5eb370
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:661)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1476)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1449)
<<<<<<< HEAD

!ENTRY org.eclipse.egit.core 1 0 2019-05-28 11:24:42.649
!MESSAGE Using Apache MINA sshd as ssh client.
=======
>>>>>>> ac8136ce159b1b1fe653767e5b0185718b5eb370

!ENTRY org.eclipse.jdt.core 4 4 2019-05-29 23:43:52.425
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package fr.upmc.pstl;


import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.time.Period;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import fr.sorbonne_u.components.AbstractComponent;
import fr.sorbonne_u.components.annotations.OfferedInterfaces;
import fr.sorbonne_u.components.interfaces.OfferedI;
import fr.upmc.pstl.annotations.AccessType;
import fr.upmc.pstl.annotations.AccessedVars;
import fr.upmc.pstl.annotations.CyclePeriod;
import fr.upmc.pstl.annotations.Semantique;
import fr.upmc.pstl.annotations.TaskAnnotation;
import fr.upmc.pstl.exceptions.CircularityException;
import fr.upmc.pstl.exceptions.PrecedanceException;
import fr.upmc.pstl.exceptions.SchedulingException;
import fr.upmc.pstl.exceptions.TimeException;


public abstract class AbstractComponentRT extends AbstractComponent
{
	protected Map<String , Object> vars;
	protected List<Map<Method , Long>> tasks_list;
	protected List<TaskCommand> to_execute; 
	protected List<ScheduledThreadPoolExecutor> executors;
	protected int Number_of_thread;
	
	public AbstractComponentRT(String uri, Map<String , Object> vars) {
		super(uri,1,0);
		this.vars = vars;
		this.to_execute = new ArrayList<TaskCommand>();
		this.executors = new ArrayList<>();
		this.Number_of_thread = 1;
		for (int i = 0 ; i < this.Number_of_thread ; i ++) {
			this.executors.add(new ScheduledThreadPoolExecutor(1));
		}
	}
	
	public Map<String,Object> getVars(){
		return this.vars;
	}
	
	public void setVar(String varName, Object newVal){
		this.vars.put(varName, newVal);
	}
	
	public void addCall(ICommand task) {
		this.to_execute.add((TaskCommand) task);
	}
	
	protected TaskCommand getNextTask() {
		if(to_execute.size()>0) {
			TaskCommand curr = this.to_execute.get(0);
			this.to_execute.remove(0);
			return curr;
		} return null;
	}
	
	
	
	
	protected final List<Map<Method , Long>> scheduler_multi_thread (AbstractComponentRT r) {
		
		
		this.tasks_list = new ArrayList<Map<Method , Long>>();
		// looking for semantic task ?!
		List<Method> tasks = getAllMethodsAsList(r);

		
		
		for (int i = 1 ; i <= this.Number_of_thread ; i ++) {
			try {
				List<List<Method>> lists = split_list_task(tasks, i);

				for (List l : lists) {
					this.tasks_list.add(this.scheduler(r, l));	
				}
				
				
				
				/**
				 * TODO 
				 * on parcours toute les listes et on vérifie que les lectures se passe après les ecriture 
				 * dans le cas où ça passe rien à faire
				 * dans le cas contraire detecter les taches infecté corrigé leur startTime et relancer le scheduling 
				 * normalement en faisant ça une fois on peut aboutir à un ordre possible ou confirmer qu'il y en a pas.
				 * 
				 * à faire demain
				 */
				
				
				
				
				
				return tasks_list;
			} catch (TimeException 
					| PrecedanceException 
					| CircularityException 
					| SchedulingException 
					| NoSuchMethodException 
					| SecurityException e) {
				this.tasks_list = new ArrayList<Map<Method , Long>>();
				e.printStackTrace();
			}
		}
		return null;
	
	}
	
	protected void redoScheduling (AbstractComponentRT r , Map<Method , List<Method>> errors , List<Map<Method, Long>> ordre) {
		
		
		long end_befor = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
		long start_after = 0;
		
		for (Map.Entry<Method, List<Method>> e : errors.entrySet()) {
			for (Method m : e.getValue()) {
				if (end_befor > getStartTime(m , ordre))
			}
		}
		
		
	}
	
	protected long getStartTime ()
	
	
	
	

	protected final Map<Method , Long>  scheduler (AbstractComponentRT r , List<Method> tasks) throws  TimeException,
																				PrecedanceException, 
																				CircularityException, 
																				SchedulingException, 
																				NoSuchMethodException, 
																				SecurityException 
	{
	
			// looking for "taches liée à la sémantique"
			/**
			 * will be changed -> it will be given directly as a parameter -> list of Methods not Task ...
			 */
			
		
			long longer_time_offered_methods = 0;
			long smallest_time_limite_offered = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
			long latest_start_time_offered = 0;
			long semantique_size = 0;
			List<Method> task_semantique = new ArrayList<>();

			for (Method t : tasks) {
				if (AbstractComponentRT.isSemantique (t)){
					task_semantique.add(t);
					semantique_size += ((TaskAnnotation)t.getAnnotation(TaskAnnotation.class)).wcet();
				}else {
					long et = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).wcet();
					long timeLimit = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).timeLimit();
					long startTime = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).startTime();
					if (timeLimit < smallest_time_limite_offered) {
						smallest_time_limite_offered = timeLimit;
					}
					if (startTime > latest_start_time_offered) {
						latest_start_time_offered = startTime;
					}
					if (et > longer_time_offered_methods) {
						longer_time_offered_methods = et;
					}
				}
			}
			
			List<Method> ect_list = createExecuteCallTask( ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period() ,
															semantique_size,
															longer_time_offered_methods,
															smallest_time_limite_offered,
															latest_start_time_offered);
			task_semantique.addAll(ect_list);
			
			
			// cas triviaux d'exception
			long totalTime = 0;
			Map<String, Map<Method, AccessType>> variables = new HashMap<>();
			Map<String, AccessType> variablesAccessType = new HashMap<>();
			for (Method task : task_semantique) {
				TaskAnnotation annotation = (TaskAnnotation) task.getAnnotation(TaskAnnotation.class); 
				AccessedVars annotationAccess = (AccessedVars) task.getAnnotation(AccessedVars.class);

				if (annotation.timeLimit() - annotation.startTime() <= 0) {
					throw new TimeException("timeLimite - startTime < 0 in task "+task);
				}
				
				
				for (int i = 0 ; i < annotationAccess.vars().length ; i ++) {
					if (!variables.containsKey(annotationAccess.vars()[i]))
						variables.put(annotationAccess.vars()[i], new HashMap<>());
					if (!variablesAccessType.containsKey(annotationAccess.vars()[i]))
						variablesAccessType.put(annotationAccess.vars()[i], annotationAccess.accessType()[i]);
					
					variables.get(annotationAccess.vars()[i]).put(task, annotationAccess.accessType()[i]);	
					
					if (variablesAccessType.get(annotationAccess.vars()[i]) != annotationAccess.accessType()[i])
						variablesAccessType.put(annotationAccess.vars()[i], AccessType.BOTH);
				}
				totalTime += annotation.wcet();
				if (annotation.timeLimit() < annotation.wcet())
					throw new TimeException("impossible to satisfy "+TaskAnnotation.class+" deadLine");	
			}
			
			
			if (totalTime > r.getClass().getAnnotation(CyclePeriod.class).period())
				throw new TimeException("period exceeded");

			
			for (String key : variablesAccessType.keySet()) {
				if ( variablesAccessType.get(key) == AccessType.READ )
					throw new PrecedanceException("trying to read unwritten variable "+key);
			}
			
			// test circularité
			for ( String s1 : variables.keySet()) {
				for (String s2 : variables.keySet()) {
					if ( ! s2.equals(s1)) {
						for (Method t1 : variables.get(s1).keySet()) {
							for (Method t2 : variables.get(s2).keySet()) {
								if ((! t1.equals(t2)) && variables.get(s2).keySet().contains(t1) && variables.get(s1).keySet().contains(t2)) {
									if (variables.get(s1).get(t1) == AccessType.READ && variables.get(s2).get(t1) == AccessType.WRITE
											&& variables.get(s1).get(t2) == AccessType.WRITE && variables.get(s2).get(t2) == AccessType.READ
											)
										throw new CircularityException("the task "+t1+" read "+s2+" and write "+s1+" and the task "+t2+" does the symestrique operation");
									
									if (variables.get(s1).get(t1) == AccessType.WRITE && variables.get(s2).get(t1) == AccessType.READ
											&& variables.get(s1).get(t2) == AccessType.READ && variables.get(s2).get(t2) == AccessType.WRITE
											)
										throw new CircularityException("the task "+t2+" read "+s1+" and write "+s2+" and the task "+t1+" does the symestrique operation");	
								}
							}
						}
					}
				}
			}
			//calcul de l'ordonnanceur
			
			// placer dans la liste des tasks un ordre (une initilisation) ex : (le temps de terminaison croissant)
			// utiliser peut être une relation d'ordre partiel -tri topologique-
			task_semantique.sort(new MethodComparator());
			long cycle_of_component = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();

			

			Map<Method , Long> ord = new HashMap<Method, Long>();
			
			if(ect_list.size() != 0) {
				while(thereIsECT(task_semantique)) {
					ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
					
					if (ord.size() == task_semantique.size())
						break;
					
					Iterator<Method> it = task_semantique.iterator();
					while (it.hasNext()) {
						Method m = it.next();
						if (m.getName()=="executeCallTask") {
							task_semantique.remove(m);
							break;
						}
					}
					
				}
				
				if (!thereIsECT(task_semantique)) {
					throw new SchedulingException("impossible to schedul on one thread ");
				}
			}else { 
				ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
				if (ord.size() != task_semantique.size())
					throw new SchedulingException("impossible to schedul on one thread ");
			}
			return ord;
	}
	
	protected boolean thereIsECT(List<Method> tasks) {
		int cpt = 0;
		for(Method m : tasks)
			if(m.getName()=="executeCallTask")
				cpt++;
		return cpt>0;
	}
	
	
	/**
	 * used to create as many as possible of executeCallTasks
	 * @return all executeCallTasks created
	 * @throws SecurityException 
	 * @throws NoSuchMethodException 
	 */
	private List<Method> createExecuteCallTask(long periode , 
												long semantique_time , 
												long largest_wcet,
												long smallest_timeLimit,
												long largest_startTime) throws NoSuchMethodException, SecurityException {
		List<Method> offered = allOffredMethod();
		
		if (offered.size() == 0) {
			return new ArrayList<Method>();
		}

		Map<String , AccessType> variables = new HashMap<String, AccessType>();
		
	
		String [] vars;
		AccessType [] types;
		for (Method mI : offered) {
			Class [] params = {java.lang.Object[].class, java.util.concurrent.CompletableFuture.class};
			Method m = this.getClass().getMethod(mI.getName(),params);
			vars = ((AccessedVars) m.getAnnotation(AccessedVars.class)).vars();
			types = ((AccessedVars) m.getAnnotation(AccessedVars.class)).accessType();
			for (int i = 0 ; i < vars.length ; i ++) {
				if (!variables.containsKey(vars[i])) {
					variables.put(vars[i], types[i]);
				}else {
					if (!variables.get(vars[i]).equals(types[i])) 
						variables.put(vars[i], AccessType.BOTH);
				}
			
			}
		}
		
		String [] vars_accessed = new String[variables.size()];
		AccessType [] typeAccess = new AccessType[variables.size()];
		int j = 0;
		for (Map.Entry<String, AccessType> e : variables.entrySet()) {
			vars_accessed[j] = e.getKey();
			typeAccess[j++] = e.getValue();
		}
		
		List<Method> ect_list = new ArrayList<>();
		int nb_ect = (int) ((periode - semantique_time)/largest_wcet);

		try {
			for( int i = 0 ; i < nb_ect ; i ++) {
				Method m = AbstractComponentRT.class.getMethod("executeCallTask");
				alterAnnotationValue(m , vars_accessed , typeAccess,
										smallest_timeLimit, largest_startTime, largest_wcet  );

				ect_list.add(m);
			}
		}catch( Exception e ) {
			e.printStackTrace();
			return null;
		}
		
		return ect_list;
	}
	
	
	
	/**
	 * used in createExecuteCallTask to get the value of wcet, timeLimit ...
	 * @return all offered method by the component
	 */
	private List<Method> allOffredMethod () {
		List<Method> offered = new ArrayList<Method>();
		OfferedInterfaces oi = ((OfferedInterfaces)this.getClass().getAnnotation(OfferedInterfaces.class));
		if(oi == null)
			return offered;
		Class[] offred = oi.offered();
		for (Class c : offred) {
			Method [] methods = c.getDeclaredMethods();
			for (int i = 0 ; i < methods.length ; i ++ ) {
				offered.add(methods[i]);
			}
		}
		return offered;
	}
	
	
	private void alterAnnotationValue (	Method m ,
										String [] vars ,
										AccessType[] type, 
										long timeLimit , 
										long startTime , 
										long wcet) 
	{
		try {

			
			Object handler_TaskAnnotation = Proxy.getInvocationHandler(m.getAnnotation(TaskAnnotation.class));
            Field memberValue_field_TaskAnnotation = handler_TaskAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_TaskAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_TaskAnnotation = (Map<String , Object>) memberValue_field_TaskAnnotation.get(handler_TaskAnnotation);

            
            memeberValues_map_TaskAnnotation.put("wcet", (long) wcet);
            memeberValues_map_TaskAnnotation.put("timeLimit", (long)timeLimit);
            memeberValues_map_TaskAnnotation.put("startTime", (long)startTime);
            
            
            

            Object handler_VarAnnotation = Proxy.getInvocationHandler(m.getAnnotation(AccessedVars.class));
            Field memberValue_field_VarAnnotation = handler_VarAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_VarAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_VarAnnotation = (Map<String , Object>) memberValue_field_VarAnnotation.get(handler_VarAnnotation);
            memeberValues_map_TaskAnnotation.put("vars", vars);
            memeberValues_map_TaskAnnotation.put("accessType", type);
            
		} catch (Exception  e) {
			e.printStackTrace();
		} 
		
	}
	
	protected final Map<Method , Long> sched (List<Method> l, Map<Method ,Long> ord , long cycle_of_component , long time_marker) 
			throws SchedulingException{
		if (l.size() == 0) {
			return ord;
		}
		List<Method> l2 = (List<Method>) ((ArrayList<Method>) l).clone();
		for (Method i : l) {
			long start_time_of_task = ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).startTime();
			if (start_time_of_task > time_marker)
				time_marker = start_time_of_task;
			ord.put(i, time_marker);
			time_marker += ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
			l2.remove(i);
			if (AbstractComponentRT.checkPossibility(ord , cycle_of_component)) {
				ord = this.sched(l2, ord , cycle_of_component , time_marker);
				return ord;
			}
			l2.add(i);
			ord.remove(i);
			time_marker -= ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
		}
		return ord;
	}
	
	
	// il faut comparer chaque élèment avec tout ceux qui le suivent
	protected static boolean  checkPossibility (Map<Method , Long> list , long cycle_of_component) {
		MethodComparator tc = new MethodComparator();
		for (Map.Entry<Method , Long> e1 : list.entrySet()) {
			if ((e1.getValue() + ((TaskAnnotation) e1.getKey().getAnnotation(TaskAnnotation.class)).wcet()) > cycle_of_component) {
				return false;
			}
			for (Map.Entry<Method , Long> e2 : list.entrySet()) {
				if (e1.getValue() < e2.getValue() ) {
					if (tc.compare(e1.getKey(), e2.getKey()) <=0)
						continue;
					return false;
				}
			}
		}
		return true;
	}
	
	
	protected static boolean isSemantique (Method method) {
		return method.isAnnotationPresent(Semantique.class);
	}
	
	
	protected List<Method> getAllMethodsAsList(AbstractComponentRT component) {
		Method m [] = component.getClass().getMethods();
		List<Method> list = new ArrayList<Method>();
		for (int i = 0 ; i < m.length  ; i ++) {
			if (m[i].isAnnotationPresent(TaskAnnotation.class) && m[i].getName()!="executeCallTask") {
				list.add(m[i]);
			}
		}
		return list;
	}
	
	protected static List<Method> getAllOfferedMethods (AbstractComponentRT component) {
		List<Method> methods = new ArrayList<>();
		OfferedInterfaces offredInterface = component.getClass().getAnnotation(OfferedInterfaces.class);
		if (offredInterface != null) {
		Class< ? extends OfferedI>[] offeredMethod = offredInterface.offered();
			for (Class< ? extends OfferedI> oi : offeredMethod ) {
				for (Method m : oi.getDeclaredMethods()) {
					methods.add(m);
				}
			}
		}
		return methods;
	}
	
	
	// last added 
	
	
	public List<List<Method>> split_list_task (List<Method> list , int nb_of_lists) {
		List<List<Method>> lists = new ArrayList<>();
		
		if (nb_of_lists <= 1) {
			lists.add(list);
			return lists;
		}
		
		
		for (int i = 0 ; i < nb_of_lists  ; i ++) {
			lists.add(new ArrayList<Method>());
		}
		
		for (int i = 0 ; i < nb_of_lists-1  ; i ++) {
			lists.get(i).add(list.get(0));
			list.remove(0);
			Iterator<Method> it = list.iterator();
			while(it.hasNext()) {
				Method cur = it.next();
				if (must_be_with(cur , lists.get(i))) {
					lists.get(i).add(cur);
					list.remove(cur);
				}
			}
		}
		
		
		//add all remaining task in the last list
		for (Method task : list)
		{
			lists.get(lists.size()-1).add(task);
		}	
		return lists;
	}
	
	
	private boolean must_be_with(Method task , List<Method> list) {
		String [] var_accessed = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).vars();
		AccessType [] type_access = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).accessType();
		Set<String> s1 = filtre_by_accessing_type(var_accessed , type_access);
		
		String [] var_accessed_by_other;
		AccessType [] type_access_by_other;
		
		for (Method t : list) {
			var_accessed_by_other = ((AccessedVars) t.getAnnotation(AccessedVars.class)).vars();
			type_access_by_other = ((AccessedVars) task.getAnnotation(AccessedVars.class)).accessType();
			Set<String> s2 = filtre_by_accessing_type(var_accessed_by_other , type_access_by_other);
			s2.retainAll(s1);
			if (s2.size() != 0) {
				return true;
			}
		}
		return false;
	}
	
	private Set<String> filtre_by_accessing_type (String [] vars , AccessType [] type) {
		Set<String> s = new HashSet<>();
		for (int i = 0 ; i < vars.length ; i ++) {
			if (type[i] == AccessType.WRITE || type[i] == AccessType.BOTH) {
				s.add(vars[i]);
			}
		}
		return s;
	}
	
	/**
	 * inutil
	 */
	private List<List<TaskCommand>> fix_start_time (List<List<TaskCommand>> lists) {
		// ici utiliser java reflect
		return null;
	}
	
	
	public void cycle () throws Exception {
		System.out.println("cycle is launched");
		long cycle_time = ((CyclePeriod) this.getClass().getAnnotation(CyclePeriod.class)).period();

		for (Map<Method , Long> i : this.tasks_list) {
			for (Map.Entry<Method, Long> t : i.entrySet()) {
			this.executors.get(this.tasks_list.indexOf(i)).scheduleAtFixedRate(()-> {
				try {
					t.getKey().invoke(this);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			,t.getValue(), cycle_time, TimeUnit.MILLISECONDS);
			}
		}
	}
	
	
	@Override 
	public <T> T handleRequestSync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
		((CompletableFuture)cf).get();
		return cf; 
	}

	@Override 
	public <T> void handleRequestAsync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
	}
	
	@AccessedVars(accessType = {  }, vars = {  })
	@TaskAnnotation(timeLimit = 0, wcet = 0 , startTime = 0)
	public void executeCallTask () throws Exception {
		ICommand task = getNextTask();
		if(task!=null) {
			((TaskCommand)task).execute();
		}
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-05-29 23:43:52.427
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-05-29 23:43:52.427
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-05-29 23:43:54.488
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package fr.upmc.pstl;


import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.time.Period;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import fr.sorbonne_u.components.AbstractComponent;
import fr.sorbonne_u.components.annotations.OfferedInterfaces;
import fr.sorbonne_u.components.interfaces.OfferedI;
import fr.upmc.pstl.annotations.AccessType;
import fr.upmc.pstl.annotations.AccessedVars;
import fr.upmc.pstl.annotations.CyclePeriod;
import fr.upmc.pstl.annotations.Semantique;
import fr.upmc.pstl.annotations.TaskAnnotation;
import fr.upmc.pstl.exceptions.CircularityException;
import fr.upmc.pstl.exceptions.PrecedanceException;
import fr.upmc.pstl.exceptions.SchedulingException;
import fr.upmc.pstl.exceptions.TimeException;


public abstract class AbstractComponentRT extends AbstractComponent
{
	protected Map<String , Object> vars;
	protected List<Map<Method , Long>> tasks_list;
	protected List<TaskCommand> to_execute; 
	protected List<ScheduledThreadPoolExecutor> executors;
	protected int Number_of_thread;
	
	public AbstractComponentRT(String uri, Map<String , Object> vars) {
		super(uri,1,0);
		this.vars = vars;
		this.to_execute = new ArrayList<TaskCommand>();
		this.executors = new ArrayList<>();
		this.Number_of_thread = 1;
		for (int i = 0 ; i < this.Number_of_thread ; i ++) {
			this.executors.add(new ScheduledThreadPoolExecutor(1));
		}
	}
	
	public Map<String,Object> getVars(){
		return this.vars;
	}
	
	public void setVar(String varName, Object newVal){
		this.vars.put(varName, newVal);
	}
	
	public void addCall(ICommand task) {
		this.to_execute.add((TaskCommand) task);
	}
	
	protected TaskCommand getNextTask() {
		if(to_execute.size()>0) {
			TaskCommand curr = this.to_execute.get(0);
			this.to_execute.remove(0);
			return curr;
		} return null;
	}
	
	
	
	
	protected final List<Map<Method , Long>> scheduler_multi_thread (AbstractComponentRT r) {
		
		
		this.tasks_list = new ArrayList<Map<Method , Long>>();
		// looking for semantic task ?!
		List<Method> tasks = getAllMethodsAsList(r);

		
		
		for (int i = 1 ; i <= this.Number_of_thread ; i ++) {
			try {
				List<List<Method>> lists = split_list_task(tasks, i);

				for (List l : lists) {
					this.tasks_list.add(this.scheduler(r, l));	
				}
				
				
				
				/**
				 * TODO 
				 * on parcours toute les listes et on vérifie que les lectures se passe après les ecriture 
				 * dans le cas où ça passe rien à faire
				 * dans le cas contraire detecter les taches infecté corrigé leur startTime et relancer le scheduling 
				 * normalement en faisant ça une fois on peut aboutir à un ordre possible ou confirmer qu'il y en a pas.
				 * 
				 * à faire demain
				 */
				
				
				
				
				
				return tasks_list;
			} catch (TimeException 
					| PrecedanceException 
					| CircularityException 
					| SchedulingException 
					| NoSuchMethodException 
					| SecurityException e) {
				this.tasks_list = new ArrayList<Map<Method , Long>>();
				e.printStackTrace();
			}
		}
		return null;
	
	}
	
	protected void redoScheduling (AbstractComponentRT r , Map<Method , List<Method>> errors , List<Map<Method, Long>> ordre) {
		
		
		long end_befor = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
		long start_after = 0;
		
		for (Map.Entry<Method, List<Method>> e : errors.entrySet()) {
			for (Method m : e.getValue()) {
				if (end_befor > getStartTime(m , ordre))
			}
		}
		
		
	}
	
	protected long getStartTime (Method )
	
	
	
	

	protected final Map<Method , Long>  scheduler (AbstractComponentRT r , List<Method> tasks) throws  TimeException,
																				PrecedanceException, 
																				CircularityException, 
																				SchedulingException, 
																				NoSuchMethodException, 
																				SecurityException 
	{
	
			// looking for "taches liée à la sémantique"
			/**
			 * will be changed -> it will be given directly as a parameter -> list of Methods not Task ...
			 */
			
		
			long longer_time_offered_methods = 0;
			long smallest_time_limite_offered = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
			long latest_start_time_offered = 0;
			long semantique_size = 0;
			List<Method> task_semantique = new ArrayList<>();

			for (Method t : tasks) {
				if (AbstractComponentRT.isSemantique (t)){
					task_semantique.add(t);
					semantique_size += ((TaskAnnotation)t.getAnnotation(TaskAnnotation.class)).wcet();
				}else {
					long et = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).wcet();
					long timeLimit = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).timeLimit();
					long startTime = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).startTime();
					if (timeLimit < smallest_time_limite_offered) {
						smallest_time_limite_offered = timeLimit;
					}
					if (startTime > latest_start_time_offered) {
						latest_start_time_offered = startTime;
					}
					if (et > longer_time_offered_methods) {
						longer_time_offered_methods = et;
					}
				}
			}
			
			List<Method> ect_list = createExecuteCallTask( ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period() ,
															semantique_size,
															longer_time_offered_methods,
															smallest_time_limite_offered,
															latest_start_time_offered);
			task_semantique.addAll(ect_list);
			
			
			// cas triviaux d'exception
			long totalTime = 0;
			Map<String, Map<Method, AccessType>> variables = new HashMap<>();
			Map<String, AccessType> variablesAccessType = new HashMap<>();
			for (Method task : task_semantique) {
				TaskAnnotation annotation = (TaskAnnotation) task.getAnnotation(TaskAnnotation.class); 
				AccessedVars annotationAccess = (AccessedVars) task.getAnnotation(AccessedVars.class);

				if (annotation.timeLimit() - annotation.startTime() <= 0) {
					throw new TimeException("timeLimite - startTime < 0 in task "+task);
				}
				
				
				for (int i = 0 ; i < annotationAccess.vars().length ; i ++) {
					if (!variables.containsKey(annotationAccess.vars()[i]))
						variables.put(annotationAccess.vars()[i], new HashMap<>());
					if (!variablesAccessType.containsKey(annotationAccess.vars()[i]))
						variablesAccessType.put(annotationAccess.vars()[i], annotationAccess.accessType()[i]);
					
					variables.get(annotationAccess.vars()[i]).put(task, annotationAccess.accessType()[i]);	
					
					if (variablesAccessType.get(annotationAccess.vars()[i]) != annotationAccess.accessType()[i])
						variablesAccessType.put(annotationAccess.vars()[i], AccessType.BOTH);
				}
				totalTime += annotation.wcet();
				if (annotation.timeLimit() < annotation.wcet())
					throw new TimeException("impossible to satisfy "+TaskAnnotation.class+" deadLine");	
			}
			
			
			if (totalTime > r.getClass().getAnnotation(CyclePeriod.class).period())
				throw new TimeException("period exceeded");

			
			for (String key : variablesAccessType.keySet()) {
				if ( variablesAccessType.get(key) == AccessType.READ )
					throw new PrecedanceException("trying to read unwritten variable "+key);
			}
			
			// test circularité
			for ( String s1 : variables.keySet()) {
				for (String s2 : variables.keySet()) {
					if ( ! s2.equals(s1)) {
						for (Method t1 : variables.get(s1).keySet()) {
							for (Method t2 : variables.get(s2).keySet()) {
								if ((! t1.equals(t2)) && variables.get(s2).keySet().contains(t1) && variables.get(s1).keySet().contains(t2)) {
									if (variables.get(s1).get(t1) == AccessType.READ && variables.get(s2).get(t1) == AccessType.WRITE
											&& variables.get(s1).get(t2) == AccessType.WRITE && variables.get(s2).get(t2) == AccessType.READ
											)
										throw new CircularityException("the task "+t1+" read "+s2+" and write "+s1+" and the task "+t2+" does the symestrique operation");
									
									if (variables.get(s1).get(t1) == AccessType.WRITE && variables.get(s2).get(t1) == AccessType.READ
											&& variables.get(s1).get(t2) == AccessType.READ && variables.get(s2).get(t2) == AccessType.WRITE
											)
										throw new CircularityException("the task "+t2+" read "+s1+" and write "+s2+" and the task "+t1+" does the symestrique operation");	
								}
							}
						}
					}
				}
			}
			//calcul de l'ordonnanceur
			
			// placer dans la liste des tasks un ordre (une initilisation) ex : (le temps de terminaison croissant)
			// utiliser peut être une relation d'ordre partiel -tri topologique-
			task_semantique.sort(new MethodComparator());
			long cycle_of_component = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();

			

			Map<Method , Long> ord = new HashMap<Method, Long>();
			
			if(ect_list.size() != 0) {
				while(thereIsECT(task_semantique)) {
					ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
					
					if (ord.size() == task_semantique.size())
						break;
					
					Iterator<Method> it = task_semantique.iterator();
					while (it.hasNext()) {
						Method m = it.next();
						if (m.getName()=="executeCallTask") {
							task_semantique.remove(m);
							break;
						}
					}
					
				}
				
				if (!thereIsECT(task_semantique)) {
					throw new SchedulingException("impossible to schedul on one thread ");
				}
			}else { 
				ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
				if (ord.size() != task_semantique.size())
					throw new SchedulingException("impossible to schedul on one thread ");
			}
			return ord;
	}
	
	protected boolean thereIsECT(List<Method> tasks) {
		int cpt = 0;
		for(Method m : tasks)
			if(m.getName()=="executeCallTask")
				cpt++;
		return cpt>0;
	}
	
	
	/**
	 * used to create as many as possible of executeCallTasks
	 * @return all executeCallTasks created
	 * @throws SecurityException 
	 * @throws NoSuchMethodException 
	 */
	private List<Method> createExecuteCallTask(long periode , 
												long semantique_time , 
												long largest_wcet,
												long smallest_timeLimit,
												long largest_startTime) throws NoSuchMethodException, SecurityException {
		List<Method> offered = allOffredMethod();
		
		if (offered.size() == 0) {
			return new ArrayList<Method>();
		}

		Map<String , AccessType> variables = new HashMap<String, AccessType>();
		
	
		String [] vars;
		AccessType [] types;
		for (Method mI : offered) {
			Class [] params = {java.lang.Object[].class, java.util.concurrent.CompletableFuture.class};
			Method m = this.getClass().getMethod(mI.getName(),params);
			vars = ((AccessedVars) m.getAnnotation(AccessedVars.class)).vars();
			types = ((AccessedVars) m.getAnnotation(AccessedVars.class)).accessType();
			for (int i = 0 ; i < vars.length ; i ++) {
				if (!variables.containsKey(vars[i])) {
					variables.put(vars[i], types[i]);
				}else {
					if (!variables.get(vars[i]).equals(types[i])) 
						variables.put(vars[i], AccessType.BOTH);
				}
			
			}
		}
		
		String [] vars_accessed = new String[variables.size()];
		AccessType [] typeAccess = new AccessType[variables.size()];
		int j = 0;
		for (Map.Entry<String, AccessType> e : variables.entrySet()) {
			vars_accessed[j] = e.getKey();
			typeAccess[j++] = e.getValue();
		}
		
		List<Method> ect_list = new ArrayList<>();
		int nb_ect = (int) ((periode - semantique_time)/largest_wcet);

		try {
			for( int i = 0 ; i < nb_ect ; i ++) {
				Method m = AbstractComponentRT.class.getMethod("executeCallTask");
				alterAnnotationValue(m , vars_accessed , typeAccess,
										smallest_timeLimit, largest_startTime, largest_wcet  );

				ect_list.add(m);
			}
		}catch( Exception e ) {
			e.printStackTrace();
			return null;
		}
		
		return ect_list;
	}
	
	
	
	/**
	 * used in createExecuteCallTask to get the value of wcet, timeLimit ...
	 * @return all offered method by the component
	 */
	private List<Method> allOffredMethod () {
		List<Method> offered = new ArrayList<Method>();
		OfferedInterfaces oi = ((OfferedInterfaces)this.getClass().getAnnotation(OfferedInterfaces.class));
		if(oi == null)
			return offered;
		Class[] offred = oi.offered();
		for (Class c : offred) {
			Method [] methods = c.getDeclaredMethods();
			for (int i = 0 ; i < methods.length ; i ++ ) {
				offered.add(methods[i]);
			}
		}
		return offered;
	}
	
	
	private void alterAnnotationValue (	Method m ,
										String [] vars ,
										AccessType[] type, 
										long timeLimit , 
										long startTime , 
										long wcet) 
	{
		try {

			
			Object handler_TaskAnnotation = Proxy.getInvocationHandler(m.getAnnotation(TaskAnnotation.class));
            Field memberValue_field_TaskAnnotation = handler_TaskAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_TaskAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_TaskAnnotation = (Map<String , Object>) memberValue_field_TaskAnnotation.get(handler_TaskAnnotation);

            
            memeberValues_map_TaskAnnotation.put("wcet", (long) wcet);
            memeberValues_map_TaskAnnotation.put("timeLimit", (long)timeLimit);
            memeberValues_map_TaskAnnotation.put("startTime", (long)startTime);
            
            
            

            Object handler_VarAnnotation = Proxy.getInvocationHandler(m.getAnnotation(AccessedVars.class));
            Field memberValue_field_VarAnnotation = handler_VarAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_VarAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_VarAnnotation = (Map<String , Object>) memberValue_field_VarAnnotation.get(handler_VarAnnotation);
            memeberValues_map_TaskAnnotation.put("vars", vars);
            memeberValues_map_TaskAnnotation.put("accessType", type);
            
		} catch (Exception  e) {
			e.printStackTrace();
		} 
		
	}
	
	protected final Map<Method , Long> sched (List<Method> l, Map<Method ,Long> ord , long cycle_of_component , long time_marker) 
			throws SchedulingException{
		if (l.size() == 0) {
			return ord;
		}
		List<Method> l2 = (List<Method>) ((ArrayList<Method>) l).clone();
		for (Method i : l) {
			long start_time_of_task = ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).startTime();
			if (start_time_of_task > time_marker)
				time_marker = start_time_of_task;
			ord.put(i, time_marker);
			time_marker += ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
			l2.remove(i);
			if (AbstractComponentRT.checkPossibility(ord , cycle_of_component)) {
				ord = this.sched(l2, ord , cycle_of_component , time_marker);
				return ord;
			}
			l2.add(i);
			ord.remove(i);
			time_marker -= ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
		}
		return ord;
	}
	
	
	// il faut comparer chaque élèment avec tout ceux qui le suivent
	protected static boolean  checkPossibility (Map<Method , Long> list , long cycle_of_component) {
		MethodComparator tc = new MethodComparator();
		for (Map.Entry<Method , Long> e1 : list.entrySet()) {
			if ((e1.getValue() + ((TaskAnnotation) e1.getKey().getAnnotation(TaskAnnotation.class)).wcet()) > cycle_of_component) {
				return false;
			}
			for (Map.Entry<Method , Long> e2 : list.entrySet()) {
				if (e1.getValue() < e2.getValue() ) {
					if (tc.compare(e1.getKey(), e2.getKey()) <=0)
						continue;
					return false;
				}
			}
		}
		return true;
	}
	
	
	protected static boolean isSemantique (Method method) {
		return method.isAnnotationPresent(Semantique.class);
	}
	
	
	protected List<Method> getAllMethodsAsList(AbstractComponentRT component) {
		Method m [] = component.getClass().getMethods();
		List<Method> list = new ArrayList<Method>();
		for (int i = 0 ; i < m.length  ; i ++) {
			if (m[i].isAnnotationPresent(TaskAnnotation.class) && m[i].getName()!="executeCallTask") {
				list.add(m[i]);
			}
		}
		return list;
	}
	
	protected static List<Method> getAllOfferedMethods (AbstractComponentRT component) {
		List<Method> methods = new ArrayList<>();
		OfferedInterfaces offredInterface = component.getClass().getAnnotation(OfferedInterfaces.class);
		if (offredInterface != null) {
		Class< ? extends OfferedI>[] offeredMethod = offredInterface.offered();
			for (Class< ? extends OfferedI> oi : offeredMethod ) {
				for (Method m : oi.getDeclaredMethods()) {
					methods.add(m);
				}
			}
		}
		return methods;
	}
	
	
	// last added 
	
	
	public List<List<Method>> split_list_task (List<Method> list , int nb_of_lists) {
		List<List<Method>> lists = new ArrayList<>();
		
		if (nb_of_lists <= 1) {
			lists.add(list);
			return lists;
		}
		
		
		for (int i = 0 ; i < nb_of_lists  ; i ++) {
			lists.add(new ArrayList<Method>());
		}
		
		for (int i = 0 ; i < nb_of_lists-1  ; i ++) {
			lists.get(i).add(list.get(0));
			list.remove(0);
			Iterator<Method> it = list.iterator();
			while(it.hasNext()) {
				Method cur = it.next();
				if (must_be_with(cur , lists.get(i))) {
					lists.get(i).add(cur);
					list.remove(cur);
				}
			}
		}
		
		
		//add all remaining task in the last list
		for (Method task : list)
		{
			lists.get(lists.size()-1).add(task);
		}	
		return lists;
	}
	
	
	private boolean must_be_with(Method task , List<Method> list) {
		String [] var_accessed = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).vars();
		AccessType [] type_access = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).accessType();
		Set<String> s1 = filtre_by_accessing_type(var_accessed , type_access);
		
		String [] var_accessed_by_other;
		AccessType [] type_access_by_other;
		
		for (Method t : list) {
			var_accessed_by_other = ((AccessedVars) t.getAnnotation(AccessedVars.class)).vars();
			type_access_by_other = ((AccessedVars) task.getAnnotation(AccessedVars.class)).accessType();
			Set<String> s2 = filtre_by_accessing_type(var_accessed_by_other , type_access_by_other);
			s2.retainAll(s1);
			if (s2.size() != 0) {
				return true;
			}
		}
		return false;
	}
	
	private Set<String> filtre_by_accessing_type (String [] vars , AccessType [] type) {
		Set<String> s = new HashSet<>();
		for (int i = 0 ; i < vars.length ; i ++) {
			if (type[i] == AccessType.WRITE || type[i] == AccessType.BOTH) {
				s.add(vars[i]);
			}
		}
		return s;
	}
	
	/**
	 * inutil
	 */
	private List<List<TaskCommand>> fix_start_time (List<List<TaskCommand>> lists) {
		// ici utiliser java reflect
		return null;
	}
	
	
	public void cycle () throws Exception {
		System.out.println("cycle is launched");
		long cycle_time = ((CyclePeriod) this.getClass().getAnnotation(CyclePeriod.class)).period();

		for (Map<Method , Long> i : this.tasks_list) {
			for (Map.Entry<Method, Long> t : i.entrySet()) {
			this.executors.get(this.tasks_list.indexOf(i)).scheduleAtFixedRate(()-> {
				try {
					t.getKey().invoke(this);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			,t.getValue(), cycle_time, TimeUnit.MILLISECONDS);
			}
		}
	}
	
	
	@Override 
	public <T> T handleRequestSync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
		((CompletableFuture)cf).get();
		return cf; 
	}

	@Override 
	public <T> void handleRequestAsync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
	}
	
	@AccessedVars(accessType = {  }, vars = {  })
	@TaskAnnotation(timeLimit = 0, wcet = 0 , startTime = 0)
	public void executeCallTask () throws Exception {
		ICommand task = getNextTask();
		if(task!=null) {
			((TaskCommand)task).execute();
		}
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-05-29 23:43:54.489
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-05-29 23:43:54.490
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-05-29 23:43:55.540
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package fr.upmc.pstl;


import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.time.Period;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import fr.sorbonne_u.components.AbstractComponent;
import fr.sorbonne_u.components.annotations.OfferedInterfaces;
import fr.sorbonne_u.components.interfaces.OfferedI;
import fr.upmc.pstl.annotations.AccessType;
import fr.upmc.pstl.annotations.AccessedVars;
import fr.upmc.pstl.annotations.CyclePeriod;
import fr.upmc.pstl.annotations.Semantique;
import fr.upmc.pstl.annotations.TaskAnnotation;
import fr.upmc.pstl.exceptions.CircularityException;
import fr.upmc.pstl.exceptions.PrecedanceException;
import fr.upmc.pstl.exceptions.SchedulingException;
import fr.upmc.pstl.exceptions.TimeException;


public abstract class AbstractComponentRT extends AbstractComponent
{
	protected Map<String , Object> vars;
	protected List<Map<Method , Long>> tasks_list;
	protected List<TaskCommand> to_execute; 
	protected List<ScheduledThreadPoolExecutor> executors;
	protected int Number_of_thread;
	
	public AbstractComponentRT(String uri, Map<String , Object> vars) {
		super(uri,1,0);
		this.vars = vars;
		this.to_execute = new ArrayList<TaskCommand>();
		this.executors = new ArrayList<>();
		this.Number_of_thread = 1;
		for (int i = 0 ; i < this.Number_of_thread ; i ++) {
			this.executors.add(new ScheduledThreadPoolExecutor(1));
		}
	}
	
	public Map<String,Object> getVars(){
		return this.vars;
	}
	
	public void setVar(String varName, Object newVal){
		this.vars.put(varName, newVal);
	}
	
	public void addCall(ICommand task) {
		this.to_execute.add((TaskCommand) task);
	}
	
	protected TaskCommand getNextTask() {
		if(to_execute.size()>0) {
			TaskCommand curr = this.to_execute.get(0);
			this.to_execute.remove(0);
			return curr;
		} return null;
	}
	
	
	
	
	protected final List<Map<Method , Long>> scheduler_multi_thread (AbstractComponentRT r) {
		
		
		this.tasks_list = new ArrayList<Map<Method , Long>>();
		// looking for semantic task ?!
		List<Method> tasks = getAllMethodsAsList(r);

		
		
		for (int i = 1 ; i <= this.Number_of_thread ; i ++) {
			try {
				List<List<Method>> lists = split_list_task(tasks, i);

				for (List l : lists) {
					this.tasks_list.add(this.scheduler(r, l));	
				}
				
				
				
				/**
				 * TODO 
				 * on parcours toute les listes et on vérifie que les lectures se passe après les ecriture 
				 * dans le cas où ça passe rien à faire
				 * dans le cas contraire detecter les taches infecté corrigé leur startTime et relancer le scheduling 
				 * normalement en faisant ça une fois on peut aboutir à un ordre possible ou confirmer qu'il y en a pas.
				 * 
				 * à faire demain
				 */
				
				
				
				
				
				return tasks_list;
			} catch (TimeException 
					| PrecedanceException 
					| CircularityException 
					| SchedulingException 
					| NoSuchMethodException 
					| SecurityException e) {
				this.tasks_list = new ArrayList<Map<Method , Long>>();
				e.printStackTrace();
			}
		}
		return null;
	
	}
	
	protected void redoScheduling (AbstractComponentRT r , Map<Method , List<Method>> errors , List<Map<Method, Long>> ordre) {
		
		
		long end_befor = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
		long start_after = 0;
		
		for (Map.Entry<Method, List<Method>> e : errors.entrySet()) {
			for (Method m : e.getValue()) {
				if (end_befor > getStartTime(m , ordre))
			}
		}
		
		
	}
	
	protected long getStartTime (Method m , )
	
	
	
	

	protected final Map<Method , Long>  scheduler (AbstractComponentRT r , List<Method> tasks) throws  TimeException,
																				PrecedanceException, 
																				CircularityException, 
																				SchedulingException, 
																				NoSuchMethodException, 
																				SecurityException 
	{
	
			// looking for "taches liée à la sémantique"
			/**
			 * will be changed -> it will be given directly as a parameter -> list of Methods not Task ...
			 */
			
		
			long longer_time_offered_methods = 0;
			long smallest_time_limite_offered = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
			long latest_start_time_offered = 0;
			long semantique_size = 0;
			List<Method> task_semantique = new ArrayList<>();

			for (Method t : tasks) {
				if (AbstractComponentRT.isSemantique (t)){
					task_semantique.add(t);
					semantique_size += ((TaskAnnotation)t.getAnnotation(TaskAnnotation.class)).wcet();
				}else {
					long et = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).wcet();
					long timeLimit = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).timeLimit();
					long startTime = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).startTime();
					if (timeLimit < smallest_time_limite_offered) {
						smallest_time_limite_offered = timeLimit;
					}
					if (startTime > latest_start_time_offered) {
						latest_start_time_offered = startTime;
					}
					if (et > longer_time_offered_methods) {
						longer_time_offered_methods = et;
					}
				}
			}
			
			List<Method> ect_list = createExecuteCallTask( ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period() ,
															semantique_size,
															longer_time_offered_methods,
															smallest_time_limite_offered,
															latest_start_time_offered);
			task_semantique.addAll(ect_list);
			
			
			// cas triviaux d'exception
			long totalTime = 0;
			Map<String, Map<Method, AccessType>> variables = new HashMap<>();
			Map<String, AccessType> variablesAccessType = new HashMap<>();
			for (Method task : task_semantique) {
				TaskAnnotation annotation = (TaskAnnotation) task.getAnnotation(TaskAnnotation.class); 
				AccessedVars annotationAccess = (AccessedVars) task.getAnnotation(AccessedVars.class);

				if (annotation.timeLimit() - annotation.startTime() <= 0) {
					throw new TimeException("timeLimite - startTime < 0 in task "+task);
				}
				
				
				for (int i = 0 ; i < annotationAccess.vars().length ; i ++) {
					if (!variables.containsKey(annotationAccess.vars()[i]))
						variables.put(annotationAccess.vars()[i], new HashMap<>());
					if (!variablesAccessType.containsKey(annotationAccess.vars()[i]))
						variablesAccessType.put(annotationAccess.vars()[i], annotationAccess.accessType()[i]);
					
					variables.get(annotationAccess.vars()[i]).put(task, annotationAccess.accessType()[i]);	
					
					if (variablesAccessType.get(annotationAccess.vars()[i]) != annotationAccess.accessType()[i])
						variablesAccessType.put(annotationAccess.vars()[i], AccessType.BOTH);
				}
				totalTime += annotation.wcet();
				if (annotation.timeLimit() < annotation.wcet())
					throw new TimeException("impossible to satisfy "+TaskAnnotation.class+" deadLine");	
			}
			
			
			if (totalTime > r.getClass().getAnnotation(CyclePeriod.class).period())
				throw new TimeException("period exceeded");

			
			for (String key : variablesAccessType.keySet()) {
				if ( variablesAccessType.get(key) == AccessType.READ )
					throw new PrecedanceException("trying to read unwritten variable "+key);
			}
			
			// test circularité
			for ( String s1 : variables.keySet()) {
				for (String s2 : variables.keySet()) {
					if ( ! s2.equals(s1)) {
						for (Method t1 : variables.get(s1).keySet()) {
							for (Method t2 : variables.get(s2).keySet()) {
								if ((! t1.equals(t2)) && variables.get(s2).keySet().contains(t1) && variables.get(s1).keySet().contains(t2)) {
									if (variables.get(s1).get(t1) == AccessType.READ && variables.get(s2).get(t1) == AccessType.WRITE
											&& variables.get(s1).get(t2) == AccessType.WRITE && variables.get(s2).get(t2) == AccessType.READ
											)
										throw new CircularityException("the task "+t1+" read "+s2+" and write "+s1+" and the task "+t2+" does the symestrique operation");
									
									if (variables.get(s1).get(t1) == AccessType.WRITE && variables.get(s2).get(t1) == AccessType.READ
											&& variables.get(s1).get(t2) == AccessType.READ && variables.get(s2).get(t2) == AccessType.WRITE
											)
										throw new CircularityException("the task "+t2+" read "+s1+" and write "+s2+" and the task "+t1+" does the symestrique operation");	
								}
							}
						}
					}
				}
			}
			//calcul de l'ordonnanceur
			
			// placer dans la liste des tasks un ordre (une initilisation) ex : (le temps de terminaison croissant)
			// utiliser peut être une relation d'ordre partiel -tri topologique-
			task_semantique.sort(new MethodComparator());
			long cycle_of_component = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();

			

			Map<Method , Long> ord = new HashMap<Method, Long>();
			
			if(ect_list.size() != 0) {
				while(thereIsECT(task_semantique)) {
					ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
					
					if (ord.size() == task_semantique.size())
						break;
					
					Iterator<Method> it = task_semantique.iterator();
					while (it.hasNext()) {
						Method m = it.next();
						if (m.getName()=="executeCallTask") {
							task_semantique.remove(m);
							break;
						}
					}
					
				}
				
				if (!thereIsECT(task_semantique)) {
					throw new SchedulingException("impossible to schedul on one thread ");
				}
			}else { 
				ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
				if (ord.size() != task_semantique.size())
					throw new SchedulingException("impossible to schedul on one thread ");
			}
			return ord;
	}
	
	protected boolean thereIsECT(List<Method> tasks) {
		int cpt = 0;
		for(Method m : tasks)
			if(m.getName()=="executeCallTask")
				cpt++;
		return cpt>0;
	}
	
	
	/**
	 * used to create as many as possible of executeCallTasks
	 * @return all executeCallTasks created
	 * @throws SecurityException 
	 * @throws NoSuchMethodException 
	 */
	private List<Method> createExecuteCallTask(long periode , 
												long semantique_time , 
												long largest_wcet,
												long smallest_timeLimit,
												long largest_startTime) throws NoSuchMethodException, SecurityException {
		List<Method> offered = allOffredMethod();
		
		if (offered.size() == 0) {
			return new ArrayList<Method>();
		}

		Map<String , AccessType> variables = new HashMap<String, AccessType>();
		
	
		String [] vars;
		AccessType [] types;
		for (Method mI : offered) {
			Class [] params = {java.lang.Object[].class, java.util.concurrent.CompletableFuture.class};
			Method m = this.getClass().getMethod(mI.getName(),params);
			vars = ((AccessedVars) m.getAnnotation(AccessedVars.class)).vars();
			types = ((AccessedVars) m.getAnnotation(AccessedVars.class)).accessType();
			for (int i = 0 ; i < vars.length ; i ++) {
				if (!variables.containsKey(vars[i])) {
					variables.put(vars[i], types[i]);
				}else {
					if (!variables.get(vars[i]).equals(types[i])) 
						variables.put(vars[i], AccessType.BOTH);
				}
			
			}
		}
		
		String [] vars_accessed = new String[variables.size()];
		AccessType [] typeAccess = new AccessType[variables.size()];
		int j = 0;
		for (Map.Entry<String, AccessType> e : variables.entrySet()) {
			vars_accessed[j] = e.getKey();
			typeAccess[j++] = e.getValue();
		}
		
		List<Method> ect_list = new ArrayList<>();
		int nb_ect = (int) ((periode - semantique_time)/largest_wcet);

		try {
			for( int i = 0 ; i < nb_ect ; i ++) {
				Method m = AbstractComponentRT.class.getMethod("executeCallTask");
				alterAnnotationValue(m , vars_accessed , typeAccess,
										smallest_timeLimit, largest_startTime, largest_wcet  );

				ect_list.add(m);
			}
		}catch( Exception e ) {
			e.printStackTrace();
			return null;
		}
		
		return ect_list;
	}
	
	
	
	/**
	 * used in createExecuteCallTask to get the value of wcet, timeLimit ...
	 * @return all offered method by the component
	 */
	private List<Method> allOffredMethod () {
		List<Method> offered = new ArrayList<Method>();
		OfferedInterfaces oi = ((OfferedInterfaces)this.getClass().getAnnotation(OfferedInterfaces.class));
		if(oi == null)
			return offered;
		Class[] offred = oi.offered();
		for (Class c : offred) {
			Method [] methods = c.getDeclaredMethods();
			for (int i = 0 ; i < methods.length ; i ++ ) {
				offered.add(methods[i]);
			}
		}
		return offered;
	}
	
	
	private void alterAnnotationValue (	Method m ,
										String [] vars ,
										AccessType[] type, 
										long timeLimit , 
										long startTime , 
										long wcet) 
	{
		try {

			
			Object handler_TaskAnnotation = Proxy.getInvocationHandler(m.getAnnotation(TaskAnnotation.class));
            Field memberValue_field_TaskAnnotation = handler_TaskAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_TaskAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_TaskAnnotation = (Map<String , Object>) memberValue_field_TaskAnnotation.get(handler_TaskAnnotation);

            
            memeberValues_map_TaskAnnotation.put("wcet", (long) wcet);
            memeberValues_map_TaskAnnotation.put("timeLimit", (long)timeLimit);
            memeberValues_map_TaskAnnotation.put("startTime", (long)startTime);
            
            
            

            Object handler_VarAnnotation = Proxy.getInvocationHandler(m.getAnnotation(AccessedVars.class));
            Field memberValue_field_VarAnnotation = handler_VarAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_VarAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_VarAnnotation = (Map<String , Object>) memberValue_field_VarAnnotation.get(handler_VarAnnotation);
            memeberValues_map_TaskAnnotation.put("vars", vars);
            memeberValues_map_TaskAnnotation.put("accessType", type);
            
		} catch (Exception  e) {
			e.printStackTrace();
		} 
		
	}
	
	protected final Map<Method , Long> sched (List<Method> l, Map<Method ,Long> ord , long cycle_of_component , long time_marker) 
			throws SchedulingException{
		if (l.size() == 0) {
			return ord;
		}
		List<Method> l2 = (List<Method>) ((ArrayList<Method>) l).clone();
		for (Method i : l) {
			long start_time_of_task = ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).startTime();
			if (start_time_of_task > time_marker)
				time_marker = start_time_of_task;
			ord.put(i, time_marker);
			time_marker += ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
			l2.remove(i);
			if (AbstractComponentRT.checkPossibility(ord , cycle_of_component)) {
				ord = this.sched(l2, ord , cycle_of_component , time_marker);
				return ord;
			}
			l2.add(i);
			ord.remove(i);
			time_marker -= ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
		}
		return ord;
	}
	
	
	// il faut comparer chaque élèment avec tout ceux qui le suivent
	protected static boolean  checkPossibility (Map<Method , Long> list , long cycle_of_component) {
		MethodComparator tc = new MethodComparator();
		for (Map.Entry<Method , Long> e1 : list.entrySet()) {
			if ((e1.getValue() + ((TaskAnnotation) e1.getKey().getAnnotation(TaskAnnotation.class)).wcet()) > cycle_of_component) {
				return false;
			}
			for (Map.Entry<Method , Long> e2 : list.entrySet()) {
				if (e1.getValue() < e2.getValue() ) {
					if (tc.compare(e1.getKey(), e2.getKey()) <=0)
						continue;
					return false;
				}
			}
		}
		return true;
	}
	
	
	protected static boolean isSemantique (Method method) {
		return method.isAnnotationPresent(Semantique.class);
	}
	
	
	protected List<Method> getAllMethodsAsList(AbstractComponentRT component) {
		Method m [] = component.getClass().getMethods();
		List<Method> list = new ArrayList<Method>();
		for (int i = 0 ; i < m.length  ; i ++) {
			if (m[i].isAnnotationPresent(TaskAnnotation.class) && m[i].getName()!="executeCallTask") {
				list.add(m[i]);
			}
		}
		return list;
	}
	
	protected static List<Method> getAllOfferedMethods (AbstractComponentRT component) {
		List<Method> methods = new ArrayList<>();
		OfferedInterfaces offredInterface = component.getClass().getAnnotation(OfferedInterfaces.class);
		if (offredInterface != null) {
		Class< ? extends OfferedI>[] offeredMethod = offredInterface.offered();
			for (Class< ? extends OfferedI> oi : offeredMethod ) {
				for (Method m : oi.getDeclaredMethods()) {
					methods.add(m);
				}
			}
		}
		return methods;
	}
	
	
	// last added 
	
	
	public List<List<Method>> split_list_task (List<Method> list , int nb_of_lists) {
		List<List<Method>> lists = new ArrayList<>();
		
		if (nb_of_lists <= 1) {
			lists.add(list);
			return lists;
		}
		
		
		for (int i = 0 ; i < nb_of_lists  ; i ++) {
			lists.add(new ArrayList<Method>());
		}
		
		for (int i = 0 ; i < nb_of_lists-1  ; i ++) {
			lists.get(i).add(list.get(0));
			list.remove(0);
			Iterator<Method> it = list.iterator();
			while(it.hasNext()) {
				Method cur = it.next();
				if (must_be_with(cur , lists.get(i))) {
					lists.get(i).add(cur);
					list.remove(cur);
				}
			}
		}
		
		
		//add all remaining task in the last list
		for (Method task : list)
		{
			lists.get(lists.size()-1).add(task);
		}	
		return lists;
	}
	
	
	private boolean must_be_with(Method task , List<Method> list) {
		String [] var_accessed = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).vars();
		AccessType [] type_access = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).accessType();
		Set<String> s1 = filtre_by_accessing_type(var_accessed , type_access);
		
		String [] var_accessed_by_other;
		AccessType [] type_access_by_other;
		
		for (Method t : list) {
			var_accessed_by_other = ((AccessedVars) t.getAnnotation(AccessedVars.class)).vars();
			type_access_by_other = ((AccessedVars) task.getAnnotation(AccessedVars.class)).accessType();
			Set<String> s2 = filtre_by_accessing_type(var_accessed_by_other , type_access_by_other);
			s2.retainAll(s1);
			if (s2.size() != 0) {
				return true;
			}
		}
		return false;
	}
	
	private Set<String> filtre_by_accessing_type (String [] vars , AccessType [] type) {
		Set<String> s = new HashSet<>();
		for (int i = 0 ; i < vars.length ; i ++) {
			if (type[i] == AccessType.WRITE || type[i] == AccessType.BOTH) {
				s.add(vars[i]);
			}
		}
		return s;
	}
	
	/**
	 * inutil
	 */
	private List<List<TaskCommand>> fix_start_time (List<List<TaskCommand>> lists) {
		// ici utiliser java reflect
		return null;
	}
	
	
	public void cycle () throws Exception {
		System.out.println("cycle is launched");
		long cycle_time = ((CyclePeriod) this.getClass().getAnnotation(CyclePeriod.class)).period();

		for (Map<Method , Long> i : this.tasks_list) {
			for (Map.Entry<Method, Long> t : i.entrySet()) {
			this.executors.get(this.tasks_list.indexOf(i)).scheduleAtFixedRate(()-> {
				try {
					t.getKey().invoke(this);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			,t.getValue(), cycle_time, TimeUnit.MILLISECONDS);
			}
		}
	}
	
	
	@Override 
	public <T> T handleRequestSync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
		((CompletableFuture)cf).get();
		return cf; 
	}

	@Override 
	public <T> void handleRequestAsync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
	}
	
	@AccessedVars(accessType = {  }, vars = {  })
	@TaskAnnotation(timeLimit = 0, wcet = 0 , startTime = 0)
	public void executeCallTask () throws Exception {
		ICommand task = getNextTask();
		if(task!=null) {
			((TaskCommand)task).execute();
		}
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-05-29 23:43:55.541
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-05-29 23:43:55.542
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-05-29 23:44:00.597
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package fr.upmc.pstl;


import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.time.Period;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import fr.sorbonne_u.components.AbstractComponent;
import fr.sorbonne_u.components.annotations.OfferedInterfaces;
import fr.sorbonne_u.components.interfaces.OfferedI;
import fr.upmc.pstl.annotations.AccessType;
import fr.upmc.pstl.annotations.AccessedVars;
import fr.upmc.pstl.annotations.CyclePeriod;
import fr.upmc.pstl.annotations.Semantique;
import fr.upmc.pstl.annotations.TaskAnnotation;
import fr.upmc.pstl.exceptions.CircularityException;
import fr.upmc.pstl.exceptions.PrecedanceException;
import fr.upmc.pstl.exceptions.SchedulingException;
import fr.upmc.pstl.exceptions.TimeException;


public abstract class AbstractComponentRT extends AbstractComponent
{
	protected Map<String , Object> vars;
	protected List<Map<Method , Long>> tasks_list;
	protected List<TaskCommand> to_execute; 
	protected List<ScheduledThreadPoolExecutor> executors;
	protected int Number_of_thread;
	
	public AbstractComponentRT(String uri, Map<String , Object> vars) {
		super(uri,1,0);
		this.vars = vars;
		this.to_execute = new ArrayList<TaskCommand>();
		this.executors = new ArrayList<>();
		this.Number_of_thread = 1;
		for (int i = 0 ; i < this.Number_of_thread ; i ++) {
			this.executors.add(new ScheduledThreadPoolExecutor(1));
		}
	}
	
	public Map<String,Object> getVars(){
		return this.vars;
	}
	
	public void setVar(String varName, Object newVal){
		this.vars.put(varName, newVal);
	}
	
	public void addCall(ICommand task) {
		this.to_execute.add((TaskCommand) task);
	}
	
	protected TaskCommand getNextTask() {
		if(to_execute.size()>0) {
			TaskCommand curr = this.to_execute.get(0);
			this.to_execute.remove(0);
			return curr;
		} return null;
	}
	
	
	
	
	protected final List<Map<Method , Long>> scheduler_multi_thread (AbstractComponentRT r) {
		
		
		this.tasks_list = new ArrayList<Map<Method , Long>>();
		// looking for semantic task ?!
		List<Method> tasks = getAllMethodsAsList(r);

		
		
		for (int i = 1 ; i <= this.Number_of_thread ; i ++) {
			try {
				List<List<Method>> lists = split_list_task(tasks, i);

				for (List l : lists) {
					this.tasks_list.add(this.scheduler(r, l));	
				}
				
				
				
				/**
				 * TODO 
				 * on parcours toute les listes et on vérifie que les lectures se passe après les ecriture 
				 * dans le cas où ça passe rien à faire
				 * dans le cas contraire detecter les taches infecté corrigé leur startTime et relancer le scheduling 
				 * normalement en faisant ça une fois on peut aboutir à un ordre possible ou confirmer qu'il y en a pas.
				 * 
				 * à faire demain
				 */
				
				
				
				
				
				return tasks_list;
			} catch (TimeException 
					| PrecedanceException 
					| CircularityException 
					| SchedulingException 
					| NoSuchMethodException 
					| SecurityException e) {
				this.tasks_list = new ArrayList<Map<Method , Long>>();
				e.printStackTrace();
			}
		}
		return null;
	
	}
	
	protected void redoScheduling (AbstractComponentRT r , Map<Method , List<Method>> errors , List<Map<Method, Long>> ordre) {
		
		
		long end_befor = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
		long start_after = 0;
		
		for (Map.Entry<Method, List<Method>> e : errors.entrySet()) {
			for (Method m : e.getValue()) {
				if (end_befor > getStartTime(m , ordre))
			}
		}
		
		
	}
	
	protected long getStartTime (Method m , List<Map<>>)
	
	
	
	

	protected final Map<Method , Long>  scheduler (AbstractComponentRT r , List<Method> tasks) throws  TimeException,
																				PrecedanceException, 
																				CircularityException, 
																				SchedulingException, 
																				NoSuchMethodException, 
																				SecurityException 
	{
	
			// looking for "taches liée à la sémantique"
			/**
			 * will be changed -> it will be given directly as a parameter -> list of Methods not Task ...
			 */
			
		
			long longer_time_offered_methods = 0;
			long smallest_time_limite_offered = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
			long latest_start_time_offered = 0;
			long semantique_size = 0;
			List<Method> task_semantique = new ArrayList<>();

			for (Method t : tasks) {
				if (AbstractComponentRT.isSemantique (t)){
					task_semantique.add(t);
					semantique_size += ((TaskAnnotation)t.getAnnotation(TaskAnnotation.class)).wcet();
				}else {
					long et = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).wcet();
					long timeLimit = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).timeLimit();
					long startTime = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).startTime();
					if (timeLimit < smallest_time_limite_offered) {
						smallest_time_limite_offered = timeLimit;
					}
					if (startTime > latest_start_time_offered) {
						latest_start_time_offered = startTime;
					}
					if (et > longer_time_offered_methods) {
						longer_time_offered_methods = et;
					}
				}
			}
			
			List<Method> ect_list = createExecuteCallTask( ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period() ,
															semantique_size,
															longer_time_offered_methods,
															smallest_time_limite_offered,
															latest_start_time_offered);
			task_semantique.addAll(ect_list);
			
			
			// cas triviaux d'exception
			long totalTime = 0;
			Map<String, Map<Method, AccessType>> variables = new HashMap<>();
			Map<String, AccessType> variablesAccessType = new HashMap<>();
			for (Method task : task_semantique) {
				TaskAnnotation annotation = (TaskAnnotation) task.getAnnotation(TaskAnnotation.class); 
				AccessedVars annotationAccess = (AccessedVars) task.getAnnotation(AccessedVars.class);

				if (annotation.timeLimit() - annotation.startTime() <= 0) {
					throw new TimeException("timeLimite - startTime < 0 in task "+task);
				}
				
				
				for (int i = 0 ; i < annotationAccess.vars().length ; i ++) {
					if (!variables.containsKey(annotationAccess.vars()[i]))
						variables.put(annotationAccess.vars()[i], new HashMap<>());
					if (!variablesAccessType.containsKey(annotationAccess.vars()[i]))
						variablesAccessType.put(annotationAccess.vars()[i], annotationAccess.accessType()[i]);
					
					variables.get(annotationAccess.vars()[i]).put(task, annotationAccess.accessType()[i]);	
					
					if (variablesAccessType.get(annotationAccess.vars()[i]) != annotationAccess.accessType()[i])
						variablesAccessType.put(annotationAccess.vars()[i], AccessType.BOTH);
				}
				totalTime += annotation.wcet();
				if (annotation.timeLimit() < annotation.wcet())
					throw new TimeException("impossible to satisfy "+TaskAnnotation.class+" deadLine");	
			}
			
			
			if (totalTime > r.getClass().getAnnotation(CyclePeriod.class).period())
				throw new TimeException("period exceeded");

			
			for (String key : variablesAccessType.keySet()) {
				if ( variablesAccessType.get(key) == AccessType.READ )
					throw new PrecedanceException("trying to read unwritten variable "+key);
			}
			
			// test circularité
			for ( String s1 : variables.keySet()) {
				for (String s2 : variables.keySet()) {
					if ( ! s2.equals(s1)) {
						for (Method t1 : variables.get(s1).keySet()) {
							for (Method t2 : variables.get(s2).keySet()) {
								if ((! t1.equals(t2)) && variables.get(s2).keySet().contains(t1) && variables.get(s1).keySet().contains(t2)) {
									if (variables.get(s1).get(t1) == AccessType.READ && variables.get(s2).get(t1) == AccessType.WRITE
											&& variables.get(s1).get(t2) == AccessType.WRITE && variables.get(s2).get(t2) == AccessType.READ
											)
										throw new CircularityException("the task "+t1+" read "+s2+" and write "+s1+" and the task "+t2+" does the symestrique operation");
									
									if (variables.get(s1).get(t1) == AccessType.WRITE && variables.get(s2).get(t1) == AccessType.READ
											&& variables.get(s1).get(t2) == AccessType.READ && variables.get(s2).get(t2) == AccessType.WRITE
											)
										throw new CircularityException("the task "+t2+" read "+s1+" and write "+s2+" and the task "+t1+" does the symestrique operation");	
								}
							}
						}
					}
				}
			}
			//calcul de l'ordonnanceur
			
			// placer dans la liste des tasks un ordre (une initilisation) ex : (le temps de terminaison croissant)
			// utiliser peut être une relation d'ordre partiel -tri topologique-
			task_semantique.sort(new MethodComparator());
			long cycle_of_component = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();

			

			Map<Method , Long> ord = new HashMap<Method, Long>();
			
			if(ect_list.size() != 0) {
				while(thereIsECT(task_semantique)) {
					ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
					
					if (ord.size() == task_semantique.size())
						break;
					
					Iterator<Method> it = task_semantique.iterator();
					while (it.hasNext()) {
						Method m = it.next();
						if (m.getName()=="executeCallTask") {
							task_semantique.remove(m);
							break;
						}
					}
					
				}
				
				if (!thereIsECT(task_semantique)) {
					throw new SchedulingException("impossible to schedul on one thread ");
				}
			}else { 
				ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
				if (ord.size() != task_semantique.size())
					throw new SchedulingException("impossible to schedul on one thread ");
			}
			return ord;
	}
	
	protected boolean thereIsECT(List<Method> tasks) {
		int cpt = 0;
		for(Method m : tasks)
			if(m.getName()=="executeCallTask")
				cpt++;
		return cpt>0;
	}
	
	
	/**
	 * used to create as many as possible of executeCallTasks
	 * @return all executeCallTasks created
	 * @throws SecurityException 
	 * @throws NoSuchMethodException 
	 */
	private List<Method> createExecuteCallTask(long periode , 
												long semantique_time , 
												long largest_wcet,
												long smallest_timeLimit,
												long largest_startTime) throws NoSuchMethodException, SecurityException {
		List<Method> offered = allOffredMethod();
		
		if (offered.size() == 0) {
			return new ArrayList<Method>();
		}

		Map<String , AccessType> variables = new HashMap<String, AccessType>();
		
	
		String [] vars;
		AccessType [] types;
		for (Method mI : offered) {
			Class [] params = {java.lang.Object[].class, java.util.concurrent.CompletableFuture.class};
			Method m = this.getClass().getMethod(mI.getName(),params);
			vars = ((AccessedVars) m.getAnnotation(AccessedVars.class)).vars();
			types = ((AccessedVars) m.getAnnotation(AccessedVars.class)).accessType();
			for (int i = 0 ; i < vars.length ; i ++) {
				if (!variables.containsKey(vars[i])) {
					variables.put(vars[i], types[i]);
				}else {
					if (!variables.get(vars[i]).equals(types[i])) 
						variables.put(vars[i], AccessType.BOTH);
				}
			
			}
		}
		
		String [] vars_accessed = new String[variables.size()];
		AccessType [] typeAccess = new AccessType[variables.size()];
		int j = 0;
		for (Map.Entry<String, AccessType> e : variables.entrySet()) {
			vars_accessed[j] = e.getKey();
			typeAccess[j++] = e.getValue();
		}
		
		List<Method> ect_list = new ArrayList<>();
		int nb_ect = (int) ((periode - semantique_time)/largest_wcet);

		try {
			for( int i = 0 ; i < nb_ect ; i ++) {
				Method m = AbstractComponentRT.class.getMethod("executeCallTask");
				alterAnnotationValue(m , vars_accessed , typeAccess,
										smallest_timeLimit, largest_startTime, largest_wcet  );

				ect_list.add(m);
			}
		}catch( Exception e ) {
			e.printStackTrace();
			return null;
		}
		
		return ect_list;
	}
	
	
	
	/**
	 * used in createExecuteCallTask to get the value of wcet, timeLimit ...
	 * @return all offered method by the component
	 */
	private List<Method> allOffredMethod () {
		List<Method> offered = new ArrayList<Method>();
		OfferedInterfaces oi = ((OfferedInterfaces)this.getClass().getAnnotation(OfferedInterfaces.class));
		if(oi == null)
			return offered;
		Class[] offred = oi.offered();
		for (Class c : offred) {
			Method [] methods = c.getDeclaredMethods();
			for (int i = 0 ; i < methods.length ; i ++ ) {
				offered.add(methods[i]);
			}
		}
		return offered;
	}
	
	
	private void alterAnnotationValue (	Method m ,
										String [] vars ,
										AccessType[] type, 
										long timeLimit , 
										long startTime , 
										long wcet) 
	{
		try {

			
			Object handler_TaskAnnotation = Proxy.getInvocationHandler(m.getAnnotation(TaskAnnotation.class));
            Field memberValue_field_TaskAnnotation = handler_TaskAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_TaskAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_TaskAnnotation = (Map<String , Object>) memberValue_field_TaskAnnotation.get(handler_TaskAnnotation);

            
            memeberValues_map_TaskAnnotation.put("wcet", (long) wcet);
            memeberValues_map_TaskAnnotation.put("timeLimit", (long)timeLimit);
            memeberValues_map_TaskAnnotation.put("startTime", (long)startTime);
            
            
            

            Object handler_VarAnnotation = Proxy.getInvocationHandler(m.getAnnotation(AccessedVars.class));
            Field memberValue_field_VarAnnotation = handler_VarAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_VarAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_VarAnnotation = (Map<String , Object>) memberValue_field_VarAnnotation.get(handler_VarAnnotation);
            memeberValues_map_TaskAnnotation.put("vars", vars);
            memeberValues_map_TaskAnnotation.put("accessType", type);
            
		} catch (Exception  e) {
			e.printStackTrace();
		} 
		
	}
	
	protected final Map<Method , Long> sched (List<Method> l, Map<Method ,Long> ord , long cycle_of_component , long time_marker) 
			throws SchedulingException{
		if (l.size() == 0) {
			return ord;
		}
		List<Method> l2 = (List<Method>) ((ArrayList<Method>) l).clone();
		for (Method i : l) {
			long start_time_of_task = ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).startTime();
			if (start_time_of_task > time_marker)
				time_marker = start_time_of_task;
			ord.put(i, time_marker);
			time_marker += ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
			l2.remove(i);
			if (AbstractComponentRT.checkPossibility(ord , cycle_of_component)) {
				ord = this.sched(l2, ord , cycle_of_component , time_marker);
				return ord;
			}
			l2.add(i);
			ord.remove(i);
			time_marker -= ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
		}
		return ord;
	}
	
	
	// il faut comparer chaque élèment avec tout ceux qui le suivent
	protected static boolean  checkPossibility (Map<Method , Long> list , long cycle_of_component) {
		MethodComparator tc = new MethodComparator();
		for (Map.Entry<Method , Long> e1 : list.entrySet()) {
			if ((e1.getValue() + ((TaskAnnotation) e1.getKey().getAnnotation(TaskAnnotation.class)).wcet()) > cycle_of_component) {
				return false;
			}
			for (Map.Entry<Method , Long> e2 : list.entrySet()) {
				if (e1.getValue() < e2.getValue() ) {
					if (tc.compare(e1.getKey(), e2.getKey()) <=0)
						continue;
					return false;
				}
			}
		}
		return true;
	}
	
	
	protected static boolean isSemantique (Method method) {
		return method.isAnnotationPresent(Semantique.class);
	}
	
	
	protected List<Method> getAllMethodsAsList(AbstractComponentRT component) {
		Method m [] = component.getClass().getMethods();
		List<Method> list = new ArrayList<Method>();
		for (int i = 0 ; i < m.length  ; i ++) {
			if (m[i].isAnnotationPresent(TaskAnnotation.class) && m[i].getName()!="executeCallTask") {
				list.add(m[i]);
			}
		}
		return list;
	}
	
	protected static List<Method> getAllOfferedMethods (AbstractComponentRT component) {
		List<Method> methods = new ArrayList<>();
		OfferedInterfaces offredInterface = component.getClass().getAnnotation(OfferedInterfaces.class);
		if (offredInterface != null) {
		Class< ? extends OfferedI>[] offeredMethod = offredInterface.offered();
			for (Class< ? extends OfferedI> oi : offeredMethod ) {
				for (Method m : oi.getDeclaredMethods()) {
					methods.add(m);
				}
			}
		}
		return methods;
	}
	
	
	// last added 
	
	
	public List<List<Method>> split_list_task (List<Method> list , int nb_of_lists) {
		List<List<Method>> lists = new ArrayList<>();
		
		if (nb_of_lists <= 1) {
			lists.add(list);
			return lists;
		}
		
		
		for (int i = 0 ; i < nb_of_lists  ; i ++) {
			lists.add(new ArrayList<Method>());
		}
		
		for (int i = 0 ; i < nb_of_lists-1  ; i ++) {
			lists.get(i).add(list.get(0));
			list.remove(0);
			Iterator<Method> it = list.iterator();
			while(it.hasNext()) {
				Method cur = it.next();
				if (must_be_with(cur , lists.get(i))) {
					lists.get(i).add(cur);
					list.remove(cur);
				}
			}
		}
		
		
		//add all remaining task in the last list
		for (Method task : list)
		{
			lists.get(lists.size()-1).add(task);
		}	
		return lists;
	}
	
	
	private boolean must_be_with(Method task , List<Method> list) {
		String [] var_accessed = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).vars();
		AccessType [] type_access = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).accessType();
		Set<String> s1 = filtre_by_accessing_type(var_accessed , type_access);
		
		String [] var_accessed_by_other;
		AccessType [] type_access_by_other;
		
		for (Method t : list) {
			var_accessed_by_other = ((AccessedVars) t.getAnnotation(AccessedVars.class)).vars();
			type_access_by_other = ((AccessedVars) task.getAnnotation(AccessedVars.class)).accessType();
			Set<String> s2 = filtre_by_accessing_type(var_accessed_by_other , type_access_by_other);
			s2.retainAll(s1);
			if (s2.size() != 0) {
				return true;
			}
		}
		return false;
	}
	
	private Set<String> filtre_by_accessing_type (String [] vars , AccessType [] type) {
		Set<String> s = new HashSet<>();
		for (int i = 0 ; i < vars.length ; i ++) {
			if (type[i] == AccessType.WRITE || type[i] == AccessType.BOTH) {
				s.add(vars[i]);
			}
		}
		return s;
	}
	
	/**
	 * inutil
	 */
	private List<List<TaskCommand>> fix_start_time (List<List<TaskCommand>> lists) {
		// ici utiliser java reflect
		return null;
	}
	
	
	public void cycle () throws Exception {
		System.out.println("cycle is launched");
		long cycle_time = ((CyclePeriod) this.getClass().getAnnotation(CyclePeriod.class)).period();

		for (Map<Method , Long> i : this.tasks_list) {
			for (Map.Entry<Method, Long> t : i.entrySet()) {
			this.executors.get(this.tasks_list.indexOf(i)).scheduleAtFixedRate(()-> {
				try {
					t.getKey().invoke(this);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			,t.getValue(), cycle_time, TimeUnit.MILLISECONDS);
			}
		}
	}
	
	
	@Override 
	public <T> T handleRequestSync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
		((CompletableFuture)cf).get();
		return cf; 
	}

	@Override 
	public <T> void handleRequestAsync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
	}
	
	@AccessedVars(accessType = {  }, vars = {  })
	@TaskAnnotation(timeLimit = 0, wcet = 0 , startTime = 0)
	public void executeCallTask () throws Exception {
		ICommand task = getNextTask();
		if(task!=null) {
			((TaskCommand)task).execute();
		}
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-05-29 23:44:00.598
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-05-29 23:44:00.598
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-05-29 23:44:02.144
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package fr.upmc.pstl;


import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.time.Period;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import fr.sorbonne_u.components.AbstractComponent;
import fr.sorbonne_u.components.annotations.OfferedInterfaces;
import fr.sorbonne_u.components.interfaces.OfferedI;
import fr.upmc.pstl.annotations.AccessType;
import fr.upmc.pstl.annotations.AccessedVars;
import fr.upmc.pstl.annotations.CyclePeriod;
import fr.upmc.pstl.annotations.Semantique;
import fr.upmc.pstl.annotations.TaskAnnotation;
import fr.upmc.pstl.exceptions.CircularityException;
import fr.upmc.pstl.exceptions.PrecedanceException;
import fr.upmc.pstl.exceptions.SchedulingException;
import fr.upmc.pstl.exceptions.TimeException;


public abstract class AbstractComponentRT extends AbstractComponent
{
	protected Map<String , Object> vars;
	protected List<Map<Method , Long>> tasks_list;
	protected List<TaskCommand> to_execute; 
	protected List<ScheduledThreadPoolExecutor> executors;
	protected int Number_of_thread;
	
	public AbstractComponentRT(String uri, Map<String , Object> vars) {
		super(uri,1,0);
		this.vars = vars;
		this.to_execute = new ArrayList<TaskCommand>();
		this.executors = new ArrayList<>();
		this.Number_of_thread = 1;
		for (int i = 0 ; i < this.Number_of_thread ; i ++) {
			this.executors.add(new ScheduledThreadPoolExecutor(1));
		}
	}
	
	public Map<String,Object> getVars(){
		return this.vars;
	}
	
	public void setVar(String varName, Object newVal){
		this.vars.put(varName, newVal);
	}
	
	public void addCall(ICommand task) {
		this.to_execute.add((TaskCommand) task);
	}
	
	protected TaskCommand getNextTask() {
		if(to_execute.size()>0) {
			TaskCommand curr = this.to_execute.get(0);
			this.to_execute.remove(0);
			return curr;
		} return null;
	}
	
	
	
	
	protected final List<Map<Method , Long>> scheduler_multi_thread (AbstractComponentRT r) {
		
		
		this.tasks_list = new ArrayList<Map<Method , Long>>();
		// looking for semantic task ?!
		List<Method> tasks = getAllMethodsAsList(r);

		
		
		for (int i = 1 ; i <= this.Number_of_thread ; i ++) {
			try {
				List<List<Method>> lists = split_list_task(tasks, i);

				for (List l : lists) {
					this.tasks_list.add(this.scheduler(r, l));	
				}
				
				
				
				/**
				 * TODO 
				 * on parcours toute les listes et on vérifie que les lectures se passe après les ecriture 
				 * dans le cas où ça passe rien à faire
				 * dans le cas contraire detecter les taches infecté corrigé leur startTime et relancer le scheduling 
				 * normalement en faisant ça une fois on peut aboutir à un ordre possible ou confirmer qu'il y en a pas.
				 * 
				 * à faire demain
				 */
				
				
				
				
				
				return tasks_list;
			} catch (TimeException 
					| PrecedanceException 
					| CircularityException 
					| SchedulingException 
					| NoSuchMethodException 
					| SecurityException e) {
				this.tasks_list = new ArrayList<Map<Method , Long>>();
				e.printStackTrace();
			}
		}
		return null;
	
	}
	
	protected void redoScheduling (AbstractComponentRT r , Map<Method , List<Method>> errors , List<Map<Method, Long>> ordre) {
		
		
		long end_befor = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
		long start_after = 0;
		
		for (Map.Entry<Method, List<Method>> e : errors.entrySet()) {
			for (Method m : e.getValue()) {
				if (end_befor > getStartTime(m , ordre))
			}
		}
		
		
	}
	
	protected long getStartTime (Method m , List<Map<Method>>)
	
	
	
	

	protected final Map<Method , Long>  scheduler (AbstractComponentRT r , List<Method> tasks) throws  TimeException,
																				PrecedanceException, 
																				CircularityException, 
																				SchedulingException, 
																				NoSuchMethodException, 
																				SecurityException 
	{
	
			// looking for "taches liée à la sémantique"
			/**
			 * will be changed -> it will be given directly as a parameter -> list of Methods not Task ...
			 */
			
		
			long longer_time_offered_methods = 0;
			long smallest_time_limite_offered = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
			long latest_start_time_offered = 0;
			long semantique_size = 0;
			List<Method> task_semantique = new ArrayList<>();

			for (Method t : tasks) {
				if (AbstractComponentRT.isSemantique (t)){
					task_semantique.add(t);
					semantique_size += ((TaskAnnotation)t.getAnnotation(TaskAnnotation.class)).wcet();
				}else {
					long et = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).wcet();
					long timeLimit = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).timeLimit();
					long startTime = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).startTime();
					if (timeLimit < smallest_time_limite_offered) {
						smallest_time_limite_offered = timeLimit;
					}
					if (startTime > latest_start_time_offered) {
						latest_start_time_offered = startTime;
					}
					if (et > longer_time_offered_methods) {
						longer_time_offered_methods = et;
					}
				}
			}
			
			List<Method> ect_list = createExecuteCallTask( ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period() ,
															semantique_size,
															longer_time_offered_methods,
															smallest_time_limite_offered,
															latest_start_time_offered);
			task_semantique.addAll(ect_list);
			
			
			// cas triviaux d'exception
			long totalTime = 0;
			Map<String, Map<Method, AccessType>> variables = new HashMap<>();
			Map<String, AccessType> variablesAccessType = new HashMap<>();
			for (Method task : task_semantique) {
				TaskAnnotation annotation = (TaskAnnotation) task.getAnnotation(TaskAnnotation.class); 
				AccessedVars annotationAccess = (AccessedVars) task.getAnnotation(AccessedVars.class);

				if (annotation.timeLimit() - annotation.startTime() <= 0) {
					throw new TimeException("timeLimite - startTime < 0 in task "+task);
				}
				
				
				for (int i = 0 ; i < annotationAccess.vars().length ; i ++) {
					if (!variables.containsKey(annotationAccess.vars()[i]))
						variables.put(annotationAccess.vars()[i], new HashMap<>());
					if (!variablesAccessType.containsKey(annotationAccess.vars()[i]))
						variablesAccessType.put(annotationAccess.vars()[i], annotationAccess.accessType()[i]);
					
					variables.get(annotationAccess.vars()[i]).put(task, annotationAccess.accessType()[i]);	
					
					if (variablesAccessType.get(annotationAccess.vars()[i]) != annotationAccess.accessType()[i])
						variablesAccessType.put(annotationAccess.vars()[i], AccessType.BOTH);
				}
				totalTime += annotation.wcet();
				if (annotation.timeLimit() < annotation.wcet())
					throw new TimeException("impossible to satisfy "+TaskAnnotation.class+" deadLine");	
			}
			
			
			if (totalTime > r.getClass().getAnnotation(CyclePeriod.class).period())
				throw new TimeException("period exceeded");

			
			for (String key : variablesAccessType.keySet()) {
				if ( variablesAccessType.get(key) == AccessType.READ )
					throw new PrecedanceException("trying to read unwritten variable "+key);
			}
			
			// test circularité
			for ( String s1 : variables.keySet()) {
				for (String s2 : variables.keySet()) {
					if ( ! s2.equals(s1)) {
						for (Method t1 : variables.get(s1).keySet()) {
							for (Method t2 : variables.get(s2).keySet()) {
								if ((! t1.equals(t2)) && variables.get(s2).keySet().contains(t1) && variables.get(s1).keySet().contains(t2)) {
									if (variables.get(s1).get(t1) == AccessType.READ && variables.get(s2).get(t1) == AccessType.WRITE
											&& variables.get(s1).get(t2) == AccessType.WRITE && variables.get(s2).get(t2) == AccessType.READ
											)
										throw new CircularityException("the task "+t1+" read "+s2+" and write "+s1+" and the task "+t2+" does the symestrique operation");
									
									if (variables.get(s1).get(t1) == AccessType.WRITE && variables.get(s2).get(t1) == AccessType.READ
											&& variables.get(s1).get(t2) == AccessType.READ && variables.get(s2).get(t2) == AccessType.WRITE
											)
										throw new CircularityException("the task "+t2+" read "+s1+" and write "+s2+" and the task "+t1+" does the symestrique operation");	
								}
							}
						}
					}
				}
			}
			//calcul de l'ordonnanceur
			
			// placer dans la liste des tasks un ordre (une initilisation) ex : (le temps de terminaison croissant)
			// utiliser peut être une relation d'ordre partiel -tri topologique-
			task_semantique.sort(new MethodComparator());
			long cycle_of_component = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();

			

			Map<Method , Long> ord = new HashMap<Method, Long>();
			
			if(ect_list.size() != 0) {
				while(thereIsECT(task_semantique)) {
					ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
					
					if (ord.size() == task_semantique.size())
						break;
					
					Iterator<Method> it = task_semantique.iterator();
					while (it.hasNext()) {
						Method m = it.next();
						if (m.getName()=="executeCallTask") {
							task_semantique.remove(m);
							break;
						}
					}
					
				}
				
				if (!thereIsECT(task_semantique)) {
					throw new SchedulingException("impossible to schedul on one thread ");
				}
			}else { 
				ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
				if (ord.size() != task_semantique.size())
					throw new SchedulingException("impossible to schedul on one thread ");
			}
			return ord;
	}
	
	protected boolean thereIsECT(List<Method> tasks) {
		int cpt = 0;
		for(Method m : tasks)
			if(m.getName()=="executeCallTask")
				cpt++;
		return cpt>0;
	}
	
	
	/**
	 * used to create as many as possible of executeCallTasks
	 * @return all executeCallTasks created
	 * @throws SecurityException 
	 * @throws NoSuchMethodException 
	 */
	private List<Method> createExecuteCallTask(long periode , 
												long semantique_time , 
												long largest_wcet,
												long smallest_timeLimit,
												long largest_startTime) throws NoSuchMethodException, SecurityException {
		List<Method> offered = allOffredMethod();
		
		if (offered.size() == 0) {
			return new ArrayList<Method>();
		}

		Map<String , AccessType> variables = new HashMap<String, AccessType>();
		
	
		String [] vars;
		AccessType [] types;
		for (Method mI : offered) {
			Class [] params = {java.lang.Object[].class, java.util.concurrent.CompletableFuture.class};
			Method m = this.getClass().getMethod(mI.getName(),params);
			vars = ((AccessedVars) m.getAnnotation(AccessedVars.class)).vars();
			types = ((AccessedVars) m.getAnnotation(AccessedVars.class)).accessType();
			for (int i = 0 ; i < vars.length ; i ++) {
				if (!variables.containsKey(vars[i])) {
					variables.put(vars[i], types[i]);
				}else {
					if (!variables.get(vars[i]).equals(types[i])) 
						variables.put(vars[i], AccessType.BOTH);
				}
			
			}
		}
		
		String [] vars_accessed = new String[variables.size()];
		AccessType [] typeAccess = new AccessType[variables.size()];
		int j = 0;
		for (Map.Entry<String, AccessType> e : variables.entrySet()) {
			vars_accessed[j] = e.getKey();
			typeAccess[j++] = e.getValue();
		}
		
		List<Method> ect_list = new ArrayList<>();
		int nb_ect = (int) ((periode - semantique_time)/largest_wcet);

		try {
			for( int i = 0 ; i < nb_ect ; i ++) {
				Method m = AbstractComponentRT.class.getMethod("executeCallTask");
				alterAnnotationValue(m , vars_accessed , typeAccess,
										smallest_timeLimit, largest_startTime, largest_wcet  );

				ect_list.add(m);
			}
		}catch( Exception e ) {
			e.printStackTrace();
			return null;
		}
		
		return ect_list;
	}
	
	
	
	/**
	 * used in createExecuteCallTask to get the value of wcet, timeLimit ...
	 * @return all offered method by the component
	 */
	private List<Method> allOffredMethod () {
		List<Method> offered = new ArrayList<Method>();
		OfferedInterfaces oi = ((OfferedInterfaces)this.getClass().getAnnotation(OfferedInterfaces.class));
		if(oi == null)
			return offered;
		Class[] offred = oi.offered();
		for (Class c : offred) {
			Method [] methods = c.getDeclaredMethods();
			for (int i = 0 ; i < methods.length ; i ++ ) {
				offered.add(methods[i]);
			}
		}
		return offered;
	}
	
	
	private void alterAnnotationValue (	Method m ,
										String [] vars ,
										AccessType[] type, 
										long timeLimit , 
										long startTime , 
										long wcet) 
	{
		try {

			
			Object handler_TaskAnnotation = Proxy.getInvocationHandler(m.getAnnotation(TaskAnnotation.class));
            Field memberValue_field_TaskAnnotation = handler_TaskAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_TaskAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_TaskAnnotation = (Map<String , Object>) memberValue_field_TaskAnnotation.get(handler_TaskAnnotation);

            
            memeberValues_map_TaskAnnotation.put("wcet", (long) wcet);
            memeberValues_map_TaskAnnotation.put("timeLimit", (long)timeLimit);
            memeberValues_map_TaskAnnotation.put("startTime", (long)startTime);
            
            
            

            Object handler_VarAnnotation = Proxy.getInvocationHandler(m.getAnnotation(AccessedVars.class));
            Field memberValue_field_VarAnnotation = handler_VarAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_VarAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_VarAnnotation = (Map<String , Object>) memberValue_field_VarAnnotation.get(handler_VarAnnotation);
            memeberValues_map_TaskAnnotation.put("vars", vars);
            memeberValues_map_TaskAnnotation.put("accessType", type);
            
		} catch (Exception  e) {
			e.printStackTrace();
		} 
		
	}
	
	protected final Map<Method , Long> sched (List<Method> l, Map<Method ,Long> ord , long cycle_of_component , long time_marker) 
			throws SchedulingException{
		if (l.size() == 0) {
			return ord;
		}
		List<Method> l2 = (List<Method>) ((ArrayList<Method>) l).clone();
		for (Method i : l) {
			long start_time_of_task = ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).startTime();
			if (start_time_of_task > time_marker)
				time_marker = start_time_of_task;
			ord.put(i, time_marker);
			time_marker += ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
			l2.remove(i);
			if (AbstractComponentRT.checkPossibility(ord , cycle_of_component)) {
				ord = this.sched(l2, ord , cycle_of_component , time_marker);
				return ord;
			}
			l2.add(i);
			ord.remove(i);
			time_marker -= ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
		}
		return ord;
	}
	
	
	// il faut comparer chaque élèment avec tout ceux qui le suivent
	protected static boolean  checkPossibility (Map<Method , Long> list , long cycle_of_component) {
		MethodComparator tc = new MethodComparator();
		for (Map.Entry<Method , Long> e1 : list.entrySet()) {
			if ((e1.getValue() + ((TaskAnnotation) e1.getKey().getAnnotation(TaskAnnotation.class)).wcet()) > cycle_of_component) {
				return false;
			}
			for (Map.Entry<Method , Long> e2 : list.entrySet()) {
				if (e1.getValue() < e2.getValue() ) {
					if (tc.compare(e1.getKey(), e2.getKey()) <=0)
						continue;
					return false;
				}
			}
		}
		return true;
	}
	
	
	protected static boolean isSemantique (Method method) {
		return method.isAnnotationPresent(Semantique.class);
	}
	
	
	protected List<Method> getAllMethodsAsList(AbstractComponentRT component) {
		Method m [] = component.getClass().getMethods();
		List<Method> list = new ArrayList<Method>();
		for (int i = 0 ; i < m.length  ; i ++) {
			if (m[i].isAnnotationPresent(TaskAnnotation.class) && m[i].getName()!="executeCallTask") {
				list.add(m[i]);
			}
		}
		return list;
	}
	
	protected static List<Method> getAllOfferedMethods (AbstractComponentRT component) {
		List<Method> methods = new ArrayList<>();
		OfferedInterfaces offredInterface = component.getClass().getAnnotation(OfferedInterfaces.class);
		if (offredInterface != null) {
		Class< ? extends OfferedI>[] offeredMethod = offredInterface.offered();
			for (Class< ? extends OfferedI> oi : offeredMethod ) {
				for (Method m : oi.getDeclaredMethods()) {
					methods.add(m);
				}
			}
		}
		return methods;
	}
	
	
	// last added 
	
	
	public List<List<Method>> split_list_task (List<Method> list , int nb_of_lists) {
		List<List<Method>> lists = new ArrayList<>();
		
		if (nb_of_lists <= 1) {
			lists.add(list);
			return lists;
		}
		
		
		for (int i = 0 ; i < nb_of_lists  ; i ++) {
			lists.add(new ArrayList<Method>());
		}
		
		for (int i = 0 ; i < nb_of_lists-1  ; i ++) {
			lists.get(i).add(list.get(0));
			list.remove(0);
			Iterator<Method> it = list.iterator();
			while(it.hasNext()) {
				Method cur = it.next();
				if (must_be_with(cur , lists.get(i))) {
					lists.get(i).add(cur);
					list.remove(cur);
				}
			}
		}
		
		
		//add all remaining task in the last list
		for (Method task : list)
		{
			lists.get(lists.size()-1).add(task);
		}	
		return lists;
	}
	
	
	private boolean must_be_with(Method task , List<Method> list) {
		String [] var_accessed = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).vars();
		AccessType [] type_access = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).accessType();
		Set<String> s1 = filtre_by_accessing_type(var_accessed , type_access);
		
		String [] var_accessed_by_other;
		AccessType [] type_access_by_other;
		
		for (Method t : list) {
			var_accessed_by_other = ((AccessedVars) t.getAnnotation(AccessedVars.class)).vars();
			type_access_by_other = ((AccessedVars) task.getAnnotation(AccessedVars.class)).accessType();
			Set<String> s2 = filtre_by_accessing_type(var_accessed_by_other , type_access_by_other);
			s2.retainAll(s1);
			if (s2.size() != 0) {
				return true;
			}
		}
		return false;
	}
	
	private Set<String> filtre_by_accessing_type (String [] vars , AccessType [] type) {
		Set<String> s = new HashSet<>();
		for (int i = 0 ; i < vars.length ; i ++) {
			if (type[i] == AccessType.WRITE || type[i] == AccessType.BOTH) {
				s.add(vars[i]);
			}
		}
		return s;
	}
	
	/**
	 * inutil
	 */
	private List<List<TaskCommand>> fix_start_time (List<List<TaskCommand>> lists) {
		// ici utiliser java reflect
		return null;
	}
	
	
	public void cycle () throws Exception {
		System.out.println("cycle is launched");
		long cycle_time = ((CyclePeriod) this.getClass().getAnnotation(CyclePeriod.class)).period();

		for (Map<Method , Long> i : this.tasks_list) {
			for (Map.Entry<Method, Long> t : i.entrySet()) {
			this.executors.get(this.tasks_list.indexOf(i)).scheduleAtFixedRate(()-> {
				try {
					t.getKey().invoke(this);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			,t.getValue(), cycle_time, TimeUnit.MILLISECONDS);
			}
		}
	}
	
	
	@Override 
	public <T> T handleRequestSync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
		((CompletableFuture)cf).get();
		return cf; 
	}

	@Override 
	public <T> void handleRequestAsync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
	}
	
	@AccessedVars(accessType = {  }, vars = {  })
	@TaskAnnotation(timeLimit = 0, wcet = 0 , startTime = 0)
	public void executeCallTask () throws Exception {
		ICommand task = getNextTask();
		if(task!=null) {
			((TaskCommand)task).execute();
		}
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-05-29 23:44:02.145
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-05-29 23:44:02.145
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-05-29 23:44:03.689
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package fr.upmc.pstl;


import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.time.Period;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import fr.sorbonne_u.components.AbstractComponent;
import fr.sorbonne_u.components.annotations.OfferedInterfaces;
import fr.sorbonne_u.components.interfaces.OfferedI;
import fr.upmc.pstl.annotations.AccessType;
import fr.upmc.pstl.annotations.AccessedVars;
import fr.upmc.pstl.annotations.CyclePeriod;
import fr.upmc.pstl.annotations.Semantique;
import fr.upmc.pstl.annotations.TaskAnnotation;
import fr.upmc.pstl.exceptions.CircularityException;
import fr.upmc.pstl.exceptions.PrecedanceException;
import fr.upmc.pstl.exceptions.SchedulingException;
import fr.upmc.pstl.exceptions.TimeException;


public abstract class AbstractComponentRT extends AbstractComponent
{
	protected Map<String , Object> vars;
	protected List<Map<Method , Long>> tasks_list;
	protected List<TaskCommand> to_execute; 
	protected List<ScheduledThreadPoolExecutor> executors;
	protected int Number_of_thread;
	
	public AbstractComponentRT(String uri, Map<String , Object> vars) {
		super(uri,1,0);
		this.vars = vars;
		this.to_execute = new ArrayList<TaskCommand>();
		this.executors = new ArrayList<>();
		this.Number_of_thread = 1;
		for (int i = 0 ; i < this.Number_of_thread ; i ++) {
			this.executors.add(new ScheduledThreadPoolExecutor(1));
		}
	}
	
	public Map<String,Object> getVars(){
		return this.vars;
	}
	
	public void setVar(String varName, Object newVal){
		this.vars.put(varName, newVal);
	}
	
	public void addCall(ICommand task) {
		this.to_execute.add((TaskCommand) task);
	}
	
	protected TaskCommand getNextTask() {
		if(to_execute.size()>0) {
			TaskCommand curr = this.to_execute.get(0);
			this.to_execute.remove(0);
			return curr;
		} return null;
	}
	
	
	
	
	protected final List<Map<Method , Long>> scheduler_multi_thread (AbstractComponentRT r) {
		
		
		this.tasks_list = new ArrayList<Map<Method , Long>>();
		// looking for semantic task ?!
		List<Method> tasks = getAllMethodsAsList(r);

		
		
		for (int i = 1 ; i <= this.Number_of_thread ; i ++) {
			try {
				List<List<Method>> lists = split_list_task(tasks, i);

				for (List l : lists) {
					this.tasks_list.add(this.scheduler(r, l));	
				}
				
				
				
				/**
				 * TODO 
				 * on parcours toute les listes et on vérifie que les lectures se passe après les ecriture 
				 * dans le cas où ça passe rien à faire
				 * dans le cas contraire detecter les taches infecté corrigé leur startTime et relancer le scheduling 
				 * normalement en faisant ça une fois on peut aboutir à un ordre possible ou confirmer qu'il y en a pas.
				 * 
				 * à faire demain
				 */
				
				
				
				
				
				return tasks_list;
			} catch (TimeException 
					| PrecedanceException 
					| CircularityException 
					| SchedulingException 
					| NoSuchMethodException 
					| SecurityException e) {
				this.tasks_list = new ArrayList<Map<Method , Long>>();
				e.printStackTrace();
			}
		}
		return null;
	
	}
	
	protected void redoScheduling (AbstractComponentRT r , Map<Method , List<Method>> errors , List<Map<Method, Long>> ordre) {
		
		
		long end_befor = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
		long start_after = 0;
		
		for (Map.Entry<Method, List<Method>> e : errors.entrySet()) {
			for (Method m : e.getValue()) {
				if (end_befor > getStartTime(m , ordre))
			}
		}
		
		
	}
	
	protected long getStartTime (Method m , List<Map<Method , >>)
	
	
	
	

	protected final Map<Method , Long>  scheduler (AbstractComponentRT r , List<Method> tasks) throws  TimeException,
																				PrecedanceException, 
																				CircularityException, 
																				SchedulingException, 
																				NoSuchMethodException, 
																				SecurityException 
	{
	
			// looking for "taches liée à la sémantique"
			/**
			 * will be changed -> it will be given directly as a parameter -> list of Methods not Task ...
			 */
			
		
			long longer_time_offered_methods = 0;
			long smallest_time_limite_offered = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
			long latest_start_time_offered = 0;
			long semantique_size = 0;
			List<Method> task_semantique = new ArrayList<>();

			for (Method t : tasks) {
				if (AbstractComponentRT.isSemantique (t)){
					task_semantique.add(t);
					semantique_size += ((TaskAnnotation)t.getAnnotation(TaskAnnotation.class)).wcet();
				}else {
					long et = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).wcet();
					long timeLimit = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).timeLimit();
					long startTime = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).startTime();
					if (timeLimit < smallest_time_limite_offered) {
						smallest_time_limite_offered = timeLimit;
					}
					if (startTime > latest_start_time_offered) {
						latest_start_time_offered = startTime;
					}
					if (et > longer_time_offered_methods) {
						longer_time_offered_methods = et;
					}
				}
			}
			
			List<Method> ect_list = createExecuteCallTask( ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period() ,
															semantique_size,
															longer_time_offered_methods,
															smallest_time_limite_offered,
															latest_start_time_offered);
			task_semantique.addAll(ect_list);
			
			
			// cas triviaux d'exception
			long totalTime = 0;
			Map<String, Map<Method, AccessType>> variables = new HashMap<>();
			Map<String, AccessType> variablesAccessType = new HashMap<>();
			for (Method task : task_semantique) {
				TaskAnnotation annotation = (TaskAnnotation) task.getAnnotation(TaskAnnotation.class); 
				AccessedVars annotationAccess = (AccessedVars) task.getAnnotation(AccessedVars.class);

				if (annotation.timeLimit() - annotation.startTime() <= 0) {
					throw new TimeException("timeLimite - startTime < 0 in task "+task);
				}
				
				
				for (int i = 0 ; i < annotationAccess.vars().length ; i ++) {
					if (!variables.containsKey(annotationAccess.vars()[i]))
						variables.put(annotationAccess.vars()[i], new HashMap<>());
					if (!variablesAccessType.containsKey(annotationAccess.vars()[i]))
						variablesAccessType.put(annotationAccess.vars()[i], annotationAccess.accessType()[i]);
					
					variables.get(annotationAccess.vars()[i]).put(task, annotationAccess.accessType()[i]);	
					
					if (variablesAccessType.get(annotationAccess.vars()[i]) != annotationAccess.accessType()[i])
						variablesAccessType.put(annotationAccess.vars()[i], AccessType.BOTH);
				}
				totalTime += annotation.wcet();
				if (annotation.timeLimit() < annotation.wcet())
					throw new TimeException("impossible to satisfy "+TaskAnnotation.class+" deadLine");	
			}
			
			
			if (totalTime > r.getClass().getAnnotation(CyclePeriod.class).period())
				throw new TimeException("period exceeded");

			
			for (String key : variablesAccessType.keySet()) {
				if ( variablesAccessType.get(key) == AccessType.READ )
					throw new PrecedanceException("trying to read unwritten variable "+key);
			}
			
			// test circularité
			for ( String s1 : variables.keySet()) {
				for (String s2 : variables.keySet()) {
					if ( ! s2.equals(s1)) {
						for (Method t1 : variables.get(s1).keySet()) {
							for (Method t2 : variables.get(s2).keySet()) {
								if ((! t1.equals(t2)) && variables.get(s2).keySet().contains(t1) && variables.get(s1).keySet().contains(t2)) {
									if (variables.get(s1).get(t1) == AccessType.READ && variables.get(s2).get(t1) == AccessType.WRITE
											&& variables.get(s1).get(t2) == AccessType.WRITE && variables.get(s2).get(t2) == AccessType.READ
											)
										throw new CircularityException("the task "+t1+" read "+s2+" and write "+s1+" and the task "+t2+" does the symestrique operation");
									
									if (variables.get(s1).get(t1) == AccessType.WRITE && variables.get(s2).get(t1) == AccessType.READ
											&& variables.get(s1).get(t2) == AccessType.READ && variables.get(s2).get(t2) == AccessType.WRITE
											)
										throw new CircularityException("the task "+t2+" read "+s1+" and write "+s2+" and the task "+t1+" does the symestrique operation");	
								}
							}
						}
					}
				}
			}
			//calcul de l'ordonnanceur
			
			// placer dans la liste des tasks un ordre (une initilisation) ex : (le temps de terminaison croissant)
			// utiliser peut être une relation d'ordre partiel -tri topologique-
			task_semantique.sort(new MethodComparator());
			long cycle_of_component = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();

			

			Map<Method , Long> ord = new HashMap<Method, Long>();
			
			if(ect_list.size() != 0) {
				while(thereIsECT(task_semantique)) {
					ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
					
					if (ord.size() == task_semantique.size())
						break;
					
					Iterator<Method> it = task_semantique.iterator();
					while (it.hasNext()) {
						Method m = it.next();
						if (m.getName()=="executeCallTask") {
							task_semantique.remove(m);
							break;
						}
					}
					
				}
				
				if (!thereIsECT(task_semantique)) {
					throw new SchedulingException("impossible to schedul on one thread ");
				}
			}else { 
				ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
				if (ord.size() != task_semantique.size())
					throw new SchedulingException("impossible to schedul on one thread ");
			}
			return ord;
	}
	
	protected boolean thereIsECT(List<Method> tasks) {
		int cpt = 0;
		for(Method m : tasks)
			if(m.getName()=="executeCallTask")
				cpt++;
		return cpt>0;
	}
	
	
	/**
	 * used to create as many as possible of executeCallTasks
	 * @return all executeCallTasks created
	 * @throws SecurityException 
	 * @throws NoSuchMethodException 
	 */
	private List<Method> createExecuteCallTask(long periode , 
												long semantique_time , 
												long largest_wcet,
												long smallest_timeLimit,
												long largest_startTime) throws NoSuchMethodException, SecurityException {
		List<Method> offered = allOffredMethod();
		
		if (offered.size() == 0) {
			return new ArrayList<Method>();
		}

		Map<String , AccessType> variables = new HashMap<String, AccessType>();
		
	
		String [] vars;
		AccessType [] types;
		for (Method mI : offered) {
			Class [] params = {java.lang.Object[].class, java.util.concurrent.CompletableFuture.class};
			Method m = this.getClass().getMethod(mI.getName(),params);
			vars = ((AccessedVars) m.getAnnotation(AccessedVars.class)).vars();
			types = ((AccessedVars) m.getAnnotation(AccessedVars.class)).accessType();
			for (int i = 0 ; i < vars.length ; i ++) {
				if (!variables.containsKey(vars[i])) {
					variables.put(vars[i], types[i]);
				}else {
					if (!variables.get(vars[i]).equals(types[i])) 
						variables.put(vars[i], AccessType.BOTH);
				}
			
			}
		}
		
		String [] vars_accessed = new String[variables.size()];
		AccessType [] typeAccess = new AccessType[variables.size()];
		int j = 0;
		for (Map.Entry<String, AccessType> e : variables.entrySet()) {
			vars_accessed[j] = e.getKey();
			typeAccess[j++] = e.getValue();
		}
		
		List<Method> ect_list = new ArrayList<>();
		int nb_ect = (int) ((periode - semantique_time)/largest_wcet);

		try {
			for( int i = 0 ; i < nb_ect ; i ++) {
				Method m = AbstractComponentRT.class.getMethod("executeCallTask");
				alterAnnotationValue(m , vars_accessed , typeAccess,
										smallest_timeLimit, largest_startTime, largest_wcet  );

				ect_list.add(m);
			}
		}catch( Exception e ) {
			e.printStackTrace();
			return null;
		}
		
		return ect_list;
	}
	
	
	
	/**
	 * used in createExecuteCallTask to get the value of wcet, timeLimit ...
	 * @return all offered method by the component
	 */
	private List<Method> allOffredMethod () {
		List<Method> offered = new ArrayList<Method>();
		OfferedInterfaces oi = ((OfferedInterfaces)this.getClass().getAnnotation(OfferedInterfaces.class));
		if(oi == null)
			return offered;
		Class[] offred = oi.offered();
		for (Class c : offred) {
			Method [] methods = c.getDeclaredMethods();
			for (int i = 0 ; i < methods.length ; i ++ ) {
				offered.add(methods[i]);
			}
		}
		return offered;
	}
	
	
	private void alterAnnotationValue (	Method m ,
										String [] vars ,
										AccessType[] type, 
										long timeLimit , 
										long startTime , 
										long wcet) 
	{
		try {

			
			Object handler_TaskAnnotation = Proxy.getInvocationHandler(m.getAnnotation(TaskAnnotation.class));
            Field memberValue_field_TaskAnnotation = handler_TaskAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_TaskAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_TaskAnnotation = (Map<String , Object>) memberValue_field_TaskAnnotation.get(handler_TaskAnnotation);

            
            memeberValues_map_TaskAnnotation.put("wcet", (long) wcet);
            memeberValues_map_TaskAnnotation.put("timeLimit", (long)timeLimit);
            memeberValues_map_TaskAnnotation.put("startTime", (long)startTime);
            
            
            

            Object handler_VarAnnotation = Proxy.getInvocationHandler(m.getAnnotation(AccessedVars.class));
            Field memberValue_field_VarAnnotation = handler_VarAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_VarAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_VarAnnotation = (Map<String , Object>) memberValue_field_VarAnnotation.get(handler_VarAnnotation);
            memeberValues_map_TaskAnnotation.put("vars", vars);
            memeberValues_map_TaskAnnotation.put("accessType", type);
            
		} catch (Exception  e) {
			e.printStackTrace();
		} 
		
	}
	
	protected final Map<Method , Long> sched (List<Method> l, Map<Method ,Long> ord , long cycle_of_component , long time_marker) 
			throws SchedulingException{
		if (l.size() == 0) {
			return ord;
		}
		List<Method> l2 = (List<Method>) ((ArrayList<Method>) l).clone();
		for (Method i : l) {
			long start_time_of_task = ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).startTime();
			if (start_time_of_task > time_marker)
				time_marker = start_time_of_task;
			ord.put(i, time_marker);
			time_marker += ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
			l2.remove(i);
			if (AbstractComponentRT.checkPossibility(ord , cycle_of_component)) {
				ord = this.sched(l2, ord , cycle_of_component , time_marker);
				return ord;
			}
			l2.add(i);
			ord.remove(i);
			time_marker -= ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
		}
		return ord;
	}
	
	
	// il faut comparer chaque élèment avec tout ceux qui le suivent
	protected static boolean  checkPossibility (Map<Method , Long> list , long cycle_of_component) {
		MethodComparator tc = new MethodComparator();
		for (Map.Entry<Method , Long> e1 : list.entrySet()) {
			if ((e1.getValue() + ((TaskAnnotation) e1.getKey().getAnnotation(TaskAnnotation.class)).wcet()) > cycle_of_component) {
				return false;
			}
			for (Map.Entry<Method , Long> e2 : list.entrySet()) {
				if (e1.getValue() < e2.getValue() ) {
					if (tc.compare(e1.getKey(), e2.getKey()) <=0)
						continue;
					return false;
				}
			}
		}
		return true;
	}
	
	
	protected static boolean isSemantique (Method method) {
		return method.isAnnotationPresent(Semantique.class);
	}
	
	
	protected List<Method> getAllMethodsAsList(AbstractComponentRT component) {
		Method m [] = component.getClass().getMethods();
		List<Method> list = new ArrayList<Method>();
		for (int i = 0 ; i < m.length  ; i ++) {
			if (m[i].isAnnotationPresent(TaskAnnotation.class) && m[i].getName()!="executeCallTask") {
				list.add(m[i]);
			}
		}
		return list;
	}
	
	protected static List<Method> getAllOfferedMethods (AbstractComponentRT component) {
		List<Method> methods = new ArrayList<>();
		OfferedInterfaces offredInterface = component.getClass().getAnnotation(OfferedInterfaces.class);
		if (offredInterface != null) {
		Class< ? extends OfferedI>[] offeredMethod = offredInterface.offered();
			for (Class< ? extends OfferedI> oi : offeredMethod ) {
				for (Method m : oi.getDeclaredMethods()) {
					methods.add(m);
				}
			}
		}
		return methods;
	}
	
	
	// last added 
	
	
	public List<List<Method>> split_list_task (List<Method> list , int nb_of_lists) {
		List<List<Method>> lists = new ArrayList<>();
		
		if (nb_of_lists <= 1) {
			lists.add(list);
			return lists;
		}
		
		
		for (int i = 0 ; i < nb_of_lists  ; i ++) {
			lists.add(new ArrayList<Method>());
		}
		
		for (int i = 0 ; i < nb_of_lists-1  ; i ++) {
			lists.get(i).add(list.get(0));
			list.remove(0);
			Iterator<Method> it = list.iterator();
			while(it.hasNext()) {
				Method cur = it.next();
				if (must_be_with(cur , lists.get(i))) {
					lists.get(i).add(cur);
					list.remove(cur);
				}
			}
		}
		
		
		//add all remaining task in the last list
		for (Method task : list)
		{
			lists.get(lists.size()-1).add(task);
		}	
		return lists;
	}
	
	
	private boolean must_be_with(Method task , List<Method> list) {
		String [] var_accessed = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).vars();
		AccessType [] type_access = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).accessType();
		Set<String> s1 = filtre_by_accessing_type(var_accessed , type_access);
		
		String [] var_accessed_by_other;
		AccessType [] type_access_by_other;
		
		for (Method t : list) {
			var_accessed_by_other = ((AccessedVars) t.getAnnotation(AccessedVars.class)).vars();
			type_access_by_other = ((AccessedVars) task.getAnnotation(AccessedVars.class)).accessType();
			Set<String> s2 = filtre_by_accessing_type(var_accessed_by_other , type_access_by_other);
			s2.retainAll(s1);
			if (s2.size() != 0) {
				return true;
			}
		}
		return false;
	}
	
	private Set<String> filtre_by_accessing_type (String [] vars , AccessType [] type) {
		Set<String> s = new HashSet<>();
		for (int i = 0 ; i < vars.length ; i ++) {
			if (type[i] == AccessType.WRITE || type[i] == AccessType.BOTH) {
				s.add(vars[i]);
			}
		}
		return s;
	}
	
	/**
	 * inutil
	 */
	private List<List<TaskCommand>> fix_start_time (List<List<TaskCommand>> lists) {
		// ici utiliser java reflect
		return null;
	}
	
	
	public void cycle () throws Exception {
		System.out.println("cycle is launched");
		long cycle_time = ((CyclePeriod) this.getClass().getAnnotation(CyclePeriod.class)).period();

		for (Map<Method , Long> i : this.tasks_list) {
			for (Map.Entry<Method, Long> t : i.entrySet()) {
			this.executors.get(this.tasks_list.indexOf(i)).scheduleAtFixedRate(()-> {
				try {
					t.getKey().invoke(this);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			,t.getValue(), cycle_time, TimeUnit.MILLISECONDS);
			}
		}
	}
	
	
	@Override 
	public <T> T handleRequestSync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
		((CompletableFuture)cf).get();
		return cf; 
	}

	@Override 
	public <T> void handleRequestAsync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
	}
	
	@AccessedVars(accessType = {  }, vars = {  })
	@TaskAnnotation(timeLimit = 0, wcet = 0 , startTime = 0)
	public void executeCallTask () throws Exception {
		ICommand task = getNextTask();
		if(task!=null) {
			((TaskCommand)task).execute();
		}
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-05-29 23:44:03.690
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-05-29 23:44:03.690
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-05-29 23:44:05.727
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package fr.upmc.pstl;


import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.time.Period;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import fr.sorbonne_u.components.AbstractComponent;
import fr.sorbonne_u.components.annotations.OfferedInterfaces;
import fr.sorbonne_u.components.interfaces.OfferedI;
import fr.upmc.pstl.annotations.AccessType;
import fr.upmc.pstl.annotations.AccessedVars;
import fr.upmc.pstl.annotations.CyclePeriod;
import fr.upmc.pstl.annotations.Semantique;
import fr.upmc.pstl.annotations.TaskAnnotation;
import fr.upmc.pstl.exceptions.CircularityException;
import fr.upmc.pstl.exceptions.PrecedanceException;
import fr.upmc.pstl.exceptions.SchedulingException;
import fr.upmc.pstl.exceptions.TimeException;


public abstract class AbstractComponentRT extends AbstractComponent
{
	protected Map<String , Object> vars;
	protected List<Map<Method , Long>> tasks_list;
	protected List<TaskCommand> to_execute; 
	protected List<ScheduledThreadPoolExecutor> executors;
	protected int Number_of_thread;
	
	public AbstractComponentRT(String uri, Map<String , Object> vars) {
		super(uri,1,0);
		this.vars = vars;
		this.to_execute = new ArrayList<TaskCommand>();
		this.executors = new ArrayList<>();
		this.Number_of_thread = 1;
		for (int i = 0 ; i < this.Number_of_thread ; i ++) {
			this.executors.add(new ScheduledThreadPoolExecutor(1));
		}
	}
	
	public Map<String,Object> getVars(){
		return this.vars;
	}
	
	public void setVar(String varName, Object newVal){
		this.vars.put(varName, newVal);
	}
	
	public void addCall(ICommand task) {
		this.to_execute.add((TaskCommand) task);
	}
	
	protected TaskCommand getNextTask() {
		if(to_execute.size()>0) {
			TaskCommand curr = this.to_execute.get(0);
			this.to_execute.remove(0);
			return curr;
		} return null;
	}
	
	
	
	
	protected final List<Map<Method , Long>> scheduler_multi_thread (AbstractComponentRT r) {
		
		
		this.tasks_list = new ArrayList<Map<Method , Long>>();
		// looking for semantic task ?!
		List<Method> tasks = getAllMethodsAsList(r);

		
		
		for (int i = 1 ; i <= this.Number_of_thread ; i ++) {
			try {
				List<List<Method>> lists = split_list_task(tasks, i);

				for (List l : lists) {
					this.tasks_list.add(this.scheduler(r, l));	
				}
				
				
				
				/**
				 * TODO 
				 * on parcours toute les listes et on vérifie que les lectures se passe après les ecriture 
				 * dans le cas où ça passe rien à faire
				 * dans le cas contraire detecter les taches infecté corrigé leur startTime et relancer le scheduling 
				 * normalement en faisant ça une fois on peut aboutir à un ordre possible ou confirmer qu'il y en a pas.
				 * 
				 * à faire demain
				 */
				
				
				
				
				
				return tasks_list;
			} catch (TimeException 
					| PrecedanceException 
					| CircularityException 
					| SchedulingException 
					| NoSuchMethodException 
					| SecurityException e) {
				this.tasks_list = new ArrayList<Map<Method , Long>>();
				e.printStackTrace();
			}
		}
		return null;
	
	}
	
	protected void redoScheduling (AbstractComponentRT r , Map<Method , List<Method>> errors , List<Map<Method, Long>> ordre) {
		
		
		long end_befor = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
		long start_after = 0;
		
		for (Map.Entry<Method, List<Method>> e : errors.entrySet()) {
			for (Method m : e.getValue()) {
				if (end_befor > getStartTime(m , ordre))
			}
		}
		
		
	}
	
	protected long getStartTime (Method m , List<Map<Method , Long>>)
	
	
	
	

	protected final Map<Method , Long>  scheduler (AbstractComponentRT r , List<Method> tasks) throws  TimeException,
																				PrecedanceException, 
																				CircularityException, 
																				SchedulingException, 
																				NoSuchMethodException, 
																				SecurityException 
	{
	
			// looking for "taches liée à la sémantique"
			/**
			 * will be changed -> it will be given directly as a parameter -> list of Methods not Task ...
			 */
			
		
			long longer_time_offered_methods = 0;
			long smallest_time_limite_offered = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();
			long latest_start_time_offered = 0;
			long semantique_size = 0;
			List<Method> task_semantique = new ArrayList<>();

			for (Method t : tasks) {
				if (AbstractComponentRT.isSemantique (t)){
					task_semantique.add(t);
					semantique_size += ((TaskAnnotation)t.getAnnotation(TaskAnnotation.class)).wcet();
				}else {
					long et = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).wcet();
					long timeLimit = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).timeLimit();
					long startTime = ((TaskAnnotation) t.getAnnotation(TaskAnnotation.class)).startTime();
					if (timeLimit < smallest_time_limite_offered) {
						smallest_time_limite_offered = timeLimit;
					}
					if (startTime > latest_start_time_offered) {
						latest_start_time_offered = startTime;
					}
					if (et > longer_time_offered_methods) {
						longer_time_offered_methods = et;
					}
				}
			}
			
			List<Method> ect_list = createExecuteCallTask( ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period() ,
															semantique_size,
															longer_time_offered_methods,
															smallest_time_limite_offered,
															latest_start_time_offered);
			task_semantique.addAll(ect_list);
			
			
			// cas triviaux d'exception
			long totalTime = 0;
			Map<String, Map<Method, AccessType>> variables = new HashMap<>();
			Map<String, AccessType> variablesAccessType = new HashMap<>();
			for (Method task : task_semantique) {
				TaskAnnotation annotation = (TaskAnnotation) task.getAnnotation(TaskAnnotation.class); 
				AccessedVars annotationAccess = (AccessedVars) task.getAnnotation(AccessedVars.class);

				if (annotation.timeLimit() - annotation.startTime() <= 0) {
					throw new TimeException("timeLimite - startTime < 0 in task "+task);
				}
				
				
				for (int i = 0 ; i < annotationAccess.vars().length ; i ++) {
					if (!variables.containsKey(annotationAccess.vars()[i]))
						variables.put(annotationAccess.vars()[i], new HashMap<>());
					if (!variablesAccessType.containsKey(annotationAccess.vars()[i]))
						variablesAccessType.put(annotationAccess.vars()[i], annotationAccess.accessType()[i]);
					
					variables.get(annotationAccess.vars()[i]).put(task, annotationAccess.accessType()[i]);	
					
					if (variablesAccessType.get(annotationAccess.vars()[i]) != annotationAccess.accessType()[i])
						variablesAccessType.put(annotationAccess.vars()[i], AccessType.BOTH);
				}
				totalTime += annotation.wcet();
				if (annotation.timeLimit() < annotation.wcet())
					throw new TimeException("impossible to satisfy "+TaskAnnotation.class+" deadLine");	
			}
			
			
			if (totalTime > r.getClass().getAnnotation(CyclePeriod.class).period())
				throw new TimeException("period exceeded");

			
			for (String key : variablesAccessType.keySet()) {
				if ( variablesAccessType.get(key) == AccessType.READ )
					throw new PrecedanceException("trying to read unwritten variable "+key);
			}
			
			// test circularité
			for ( String s1 : variables.keySet()) {
				for (String s2 : variables.keySet()) {
					if ( ! s2.equals(s1)) {
						for (Method t1 : variables.get(s1).keySet()) {
							for (Method t2 : variables.get(s2).keySet()) {
								if ((! t1.equals(t2)) && variables.get(s2).keySet().contains(t1) && variables.get(s1).keySet().contains(t2)) {
									if (variables.get(s1).get(t1) == AccessType.READ && variables.get(s2).get(t1) == AccessType.WRITE
											&& variables.get(s1).get(t2) == AccessType.WRITE && variables.get(s2).get(t2) == AccessType.READ
											)
										throw new CircularityException("the task "+t1+" read "+s2+" and write "+s1+" and the task "+t2+" does the symestrique operation");
									
									if (variables.get(s1).get(t1) == AccessType.WRITE && variables.get(s2).get(t1) == AccessType.READ
											&& variables.get(s1).get(t2) == AccessType.READ && variables.get(s2).get(t2) == AccessType.WRITE
											)
										throw new CircularityException("the task "+t2+" read "+s1+" and write "+s2+" and the task "+t1+" does the symestrique operation");	
								}
							}
						}
					}
				}
			}
			//calcul de l'ordonnanceur
			
			// placer dans la liste des tasks un ordre (une initilisation) ex : (le temps de terminaison croissant)
			// utiliser peut être une relation d'ordre partiel -tri topologique-
			task_semantique.sort(new MethodComparator());
			long cycle_of_component = ((CyclePeriod) r.getClass().getAnnotation(CyclePeriod.class)).period();

			

			Map<Method , Long> ord = new HashMap<Method, Long>();
			
			if(ect_list.size() != 0) {
				while(thereIsECT(task_semantique)) {
					ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
					
					if (ord.size() == task_semantique.size())
						break;
					
					Iterator<Method> it = task_semantique.iterator();
					while (it.hasNext()) {
						Method m = it.next();
						if (m.getName()=="executeCallTask") {
							task_semantique.remove(m);
							break;
						}
					}
					
				}
				
				if (!thereIsECT(task_semantique)) {
					throw new SchedulingException("impossible to schedul on one thread ");
				}
			}else { 
				ord = this.sched(task_semantique , new HashMap<Method, Long> () , cycle_of_component ,0);
				if (ord.size() != task_semantique.size())
					throw new SchedulingException("impossible to schedul on one thread ");
			}
			return ord;
	}
	
	protected boolean thereIsECT(List<Method> tasks) {
		int cpt = 0;
		for(Method m : tasks)
			if(m.getName()=="executeCallTask")
				cpt++;
		return cpt>0;
	}
	
	
	/**
	 * used to create as many as possible of executeCallTasks
	 * @return all executeCallTasks created
	 * @throws SecurityException 
	 * @throws NoSuchMethodException 
	 */
	private List<Method> createExecuteCallTask(long periode , 
												long semantique_time , 
												long largest_wcet,
												long smallest_timeLimit,
												long largest_startTime) throws NoSuchMethodException, SecurityException {
		List<Method> offered = allOffredMethod();
		
		if (offered.size() == 0) {
			return new ArrayList<Method>();
		}

		Map<String , AccessType> variables = new HashMap<String, AccessType>();
		
	
		String [] vars;
		AccessType [] types;
		for (Method mI : offered) {
			Class [] params = {java.lang.Object[].class, java.util.concurrent.CompletableFuture.class};
			Method m = this.getClass().getMethod(mI.getName(),params);
			vars = ((AccessedVars) m.getAnnotation(AccessedVars.class)).vars();
			types = ((AccessedVars) m.getAnnotation(AccessedVars.class)).accessType();
			for (int i = 0 ; i < vars.length ; i ++) {
				if (!variables.containsKey(vars[i])) {
					variables.put(vars[i], types[i]);
				}else {
					if (!variables.get(vars[i]).equals(types[i])) 
						variables.put(vars[i], AccessType.BOTH);
				}
			
			}
		}
		
		String [] vars_accessed = new String[variables.size()];
		AccessType [] typeAccess = new AccessType[variables.size()];
		int j = 0;
		for (Map.Entry<String, AccessType> e : variables.entrySet()) {
			vars_accessed[j] = e.getKey();
			typeAccess[j++] = e.getValue();
		}
		
		List<Method> ect_list = new ArrayList<>();
		int nb_ect = (int) ((periode - semantique_time)/largest_wcet);

		try {
			for( int i = 0 ; i < nb_ect ; i ++) {
				Method m = AbstractComponentRT.class.getMethod("executeCallTask");
				alterAnnotationValue(m , vars_accessed , typeAccess,
										smallest_timeLimit, largest_startTime, largest_wcet  );

				ect_list.add(m);
			}
		}catch( Exception e ) {
			e.printStackTrace();
			return null;
		}
		
		return ect_list;
	}
	
	
	
	/**
	 * used in createExecuteCallTask to get the value of wcet, timeLimit ...
	 * @return all offered method by the component
	 */
	private List<Method> allOffredMethod () {
		List<Method> offered = new ArrayList<Method>();
		OfferedInterfaces oi = ((OfferedInterfaces)this.getClass().getAnnotation(OfferedInterfaces.class));
		if(oi == null)
			return offered;
		Class[] offred = oi.offered();
		for (Class c : offred) {
			Method [] methods = c.getDeclaredMethods();
			for (int i = 0 ; i < methods.length ; i ++ ) {
				offered.add(methods[i]);
			}
		}
		return offered;
	}
	
	
	private void alterAnnotationValue (	Method m ,
										String [] vars ,
										AccessType[] type, 
										long timeLimit , 
										long startTime , 
										long wcet) 
	{
		try {

			
			Object handler_TaskAnnotation = Proxy.getInvocationHandler(m.getAnnotation(TaskAnnotation.class));
            Field memberValue_field_TaskAnnotation = handler_TaskAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_TaskAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_TaskAnnotation = (Map<String , Object>) memberValue_field_TaskAnnotation.get(handler_TaskAnnotation);

            
            memeberValues_map_TaskAnnotation.put("wcet", (long) wcet);
            memeberValues_map_TaskAnnotation.put("timeLimit", (long)timeLimit);
            memeberValues_map_TaskAnnotation.put("startTime", (long)startTime);
            
            
            

            Object handler_VarAnnotation = Proxy.getInvocationHandler(m.getAnnotation(AccessedVars.class));
            Field memberValue_field_VarAnnotation = handler_VarAnnotation.getClass().getDeclaredField("memberValues");
            memberValue_field_VarAnnotation.setAccessible(true);
            Map <String , Object> memeberValues_map_VarAnnotation = (Map<String , Object>) memberValue_field_VarAnnotation.get(handler_VarAnnotation);
            memeberValues_map_TaskAnnotation.put("vars", vars);
            memeberValues_map_TaskAnnotation.put("accessType", type);
            
		} catch (Exception  e) {
			e.printStackTrace();
		} 
		
	}
	
	protected final Map<Method , Long> sched (List<Method> l, Map<Method ,Long> ord , long cycle_of_component , long time_marker) 
			throws SchedulingException{
		if (l.size() == 0) {
			return ord;
		}
		List<Method> l2 = (List<Method>) ((ArrayList<Method>) l).clone();
		for (Method i : l) {
			long start_time_of_task = ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).startTime();
			if (start_time_of_task > time_marker)
				time_marker = start_time_of_task;
			ord.put(i, time_marker);
			time_marker += ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
			l2.remove(i);
			if (AbstractComponentRT.checkPossibility(ord , cycle_of_component)) {
				ord = this.sched(l2, ord , cycle_of_component , time_marker);
				return ord;
			}
			l2.add(i);
			ord.remove(i);
			time_marker -= ((TaskAnnotation) i.getAnnotation(TaskAnnotation.class)).wcet();
		}
		return ord;
	}
	
	
	// il faut comparer chaque élèment avec tout ceux qui le suivent
	protected static boolean  checkPossibility (Map<Method , Long> list , long cycle_of_component) {
		MethodComparator tc = new MethodComparator();
		for (Map.Entry<Method , Long> e1 : list.entrySet()) {
			if ((e1.getValue() + ((TaskAnnotation) e1.getKey().getAnnotation(TaskAnnotation.class)).wcet()) > cycle_of_component) {
				return false;
			}
			for (Map.Entry<Method , Long> e2 : list.entrySet()) {
				if (e1.getValue() < e2.getValue() ) {
					if (tc.compare(e1.getKey(), e2.getKey()) <=0)
						continue;
					return false;
				}
			}
		}
		return true;
	}
	
	
	protected static boolean isSemantique (Method method) {
		return method.isAnnotationPresent(Semantique.class);
	}
	
	
	protected List<Method> getAllMethodsAsList(AbstractComponentRT component) {
		Method m [] = component.getClass().getMethods();
		List<Method> list = new ArrayList<Method>();
		for (int i = 0 ; i < m.length  ; i ++) {
			if (m[i].isAnnotationPresent(TaskAnnotation.class) && m[i].getName()!="executeCallTask") {
				list.add(m[i]);
			}
		}
		return list;
	}
	
	protected static List<Method> getAllOfferedMethods (AbstractComponentRT component) {
		List<Method> methods = new ArrayList<>();
		OfferedInterfaces offredInterface = component.getClass().getAnnotation(OfferedInterfaces.class);
		if (offredInterface != null) {
		Class< ? extends OfferedI>[] offeredMethod = offredInterface.offered();
			for (Class< ? extends OfferedI> oi : offeredMethod ) {
				for (Method m : oi.getDeclaredMethods()) {
					methods.add(m);
				}
			}
		}
		return methods;
	}
	
	
	// last added 
	
	
	public List<List<Method>> split_list_task (List<Method> list , int nb_of_lists) {
		List<List<Method>> lists = new ArrayList<>();
		
		if (nb_of_lists <= 1) {
			lists.add(list);
			return lists;
		}
		
		
		for (int i = 0 ; i < nb_of_lists  ; i ++) {
			lists.add(new ArrayList<Method>());
		}
		
		for (int i = 0 ; i < nb_of_lists-1  ; i ++) {
			lists.get(i).add(list.get(0));
			list.remove(0);
			Iterator<Method> it = list.iterator();
			while(it.hasNext()) {
				Method cur = it.next();
				if (must_be_with(cur , lists.get(i))) {
					lists.get(i).add(cur);
					list.remove(cur);
				}
			}
		}
		
		
		//add all remaining task in the last list
		for (Method task : list)
		{
			lists.get(lists.size()-1).add(task);
		}	
		return lists;
	}
	
	
	private boolean must_be_with(Method task , List<Method> list) {
		String [] var_accessed = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).vars();
		AccessType [] type_access = ((AccessedVars) task.getClass().getAnnotation(AccessedVars.class)).accessType();
		Set<String> s1 = filtre_by_accessing_type(var_accessed , type_access);
		
		String [] var_accessed_by_other;
		AccessType [] type_access_by_other;
		
		for (Method t : list) {
			var_accessed_by_other = ((AccessedVars) t.getAnnotation(AccessedVars.class)).vars();
			type_access_by_other = ((AccessedVars) task.getAnnotation(AccessedVars.class)).accessType();
			Set<String> s2 = filtre_by_accessing_type(var_accessed_by_other , type_access_by_other);
			s2.retainAll(s1);
			if (s2.size() != 0) {
				return true;
			}
		}
		return false;
	}
	
	private Set<String> filtre_by_accessing_type (String [] vars , AccessType [] type) {
		Set<String> s = new HashSet<>();
		for (int i = 0 ; i < vars.length ; i ++) {
			if (type[i] == AccessType.WRITE || type[i] == AccessType.BOTH) {
				s.add(vars[i]);
			}
		}
		return s;
	}
	
	/**
	 * inutil
	 */
	private List<List<TaskCommand>> fix_start_time (List<List<TaskCommand>> lists) {
		// ici utiliser java reflect
		return null;
	}
	
	
	public void cycle () throws Exception {
		System.out.println("cycle is launched");
		long cycle_time = ((CyclePeriod) this.getClass().getAnnotation(CyclePeriod.class)).period();

		for (Map<Method , Long> i : this.tasks_list) {
			for (Map.Entry<Method, Long> t : i.entrySet()) {
			this.executors.get(this.tasks_list.indexOf(i)).scheduleAtFixedRate(()-> {
				try {
					t.getKey().invoke(this);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			,t.getValue(), cycle_time, TimeUnit.MILLISECONDS);
			}
		}
	}
	
	
	@Override 
	public <T> T handleRequestSync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
		((CompletableFuture)cf).get();
		return cf; 
	}

	@Override 
	public <T> void handleRequestAsync(ComponentService<T> task) throws Exception { 
		T cf = task.call(); 
		assert cf instanceof CompletableFuture; 
	}
	
	@AccessedVars(accessType = {  }, vars = {  })
	@TaskAnnotation(timeLimit = 0, wcet = 0 , startTime = 0)
	public void executeCallTask () throws Exception {
		ICommand task = getNextTask();
		if(task!=null) {
			((TaskCommand)task).execute();
		}
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-05-29 23:44:05.727
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-05-29 23:44:05.727
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2949)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:636)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3036)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1393)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
