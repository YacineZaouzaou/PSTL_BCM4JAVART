package fr.upmc.pstl.exemples.basic.components;

import java.util.List;
import java.util.Map;

import fr.upmc.components.annotations.RequiredInterfaces;
import fr.upmc.components.exceptions.ComponentStartException;
import fr.upmc.pstl.AbstractComponentRT;
import fr.upmc.pstl.AbstractTask;
import fr.upmc.pstl.annotations.CyclePeriod;
import fr.upmc.pstl.exemples.basic.interfaces.ConsumerI;
import fr.upmc.pstl.exemples.basic.ports.ConsumerOutBoundPort;

@CyclePeriod(period = 15)
@RequiredInterfaces(required = {ConsumerI.class})
public class Consumer 
extends AbstractComponentRT{
	
	protected ConsumerOutBoundPort uriGetterPort;

	public Consumer(
			String uri, 
			String consumerPortURI,
			Map<String,Object> vars, 
			List<AbstractTask> tasks) throws Exception
	{
		super(uri,vars, tasks);
		
		
		this.uriGetterPort = new ConsumerOutBoundPort(consumerPortURI, this);
		
		this.addPort(this.uriGetterPort);
		
		this.uriGetterPort.publishPort();
		
		
		for (Map.entry<String, PortI>e : portURIs2ports.entrySet()) {
			
		}
		
		
	}
	
	public void cycle()  throws Exception{
		for(AbstractTask task : this.tasks) {
			task.execute();
		}
	}
	
	public ConsumerOutBoundPort getUriGetterPort () {
		return this.uriGetterPort;
	}
	
	
	public void start() throws ComponentStartException {
		super.start();
		new Thread (()->  {
			while (true) {
				try {
					cycle();
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}).start();
	}

	public void schedul() {
		this.tasks = super.scheduler(this);
	}

}
